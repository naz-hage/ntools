{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Software Tools Collection This repository contains a collection of software tools specifically designed to automate various build and test tasks on Windows clients. Whether you are a developer working on your local machine or using GitHub Actions for continuous integration, these tools will simplify your workflow and enhance your productivity. Install ntools Practice using ntools Setup your project Dev Setup Add a new tool Add a new property Add a new target Add a new task Add a new condition Don't hesitate to write an issue if you have any questions or suggestions.","title":"Overview"},{"location":"#software-tools-collection","text":"This repository contains a collection of software tools specifically designed to automate various build and test tasks on Windows clients. Whether you are a developer working on your local machine or using GitHub Actions for continuous integration, these tools will simplify your workflow and enhance your productivity. Install ntools Practice using ntools Setup your project Dev Setup Add a new tool Add a new property Add a new target Add a new task Add a new condition Don't hesitate to write an issue if you have any questions or suggestions.","title":"Software Tools Collection"},{"location":"buildtypes/","text":"ntools have two predefined build types: stage and prod . The stage build type is deploy code to a stage environment used for debugging and testing, while the prod build type is used for prod deployment. The stage build type includes debugging symbols and is not optimized, while the production build type is optimized for performance and does not include debugging symbols. stage The stage build type use the following command: nb stage It includes the following steps: Clean the project Restore the project Build the project Test the project Publish the project to the stage environment Run various tests on the stage environment The version is set according to the rules in versioning Production The prod build type use the following command: nb prod It includes the following steps: Clean the project Restore the project Build the project Test the project Publish the project to the production environment Run smoke tests on the production environment This build is available for download from the GitHub release page The version is set according to the rules in versioning Your project can have additional build types which you can add to your nbuild.targets fille,","title":"Build Types"},{"location":"buildtypes/#_1","text":"","title":""},{"location":"buildtypes/#stage","text":"The stage build type use the following command: nb stage It includes the following steps: Clean the project Restore the project Build the project Test the project Publish the project to the stage environment Run various tests on the stage environment The version is set according to the rules in versioning","title":"stage"},{"location":"buildtypes/#production","text":"The prod build type use the following command: nb prod It includes the following steps: Clean the project Restore the project Build the project Test the project Publish the project to the production environment Run smoke tests on the production environment This build is available for download from the GitHub release page The version is set according to the rules in versioning Your project can have additional build types which you can add to your nbuild.targets fille,","title":"Production"},{"location":"changelog/","text":"Latest Release","title":"Changelog"},{"location":"changelog/#latest-release","text":"","title":"Latest Release"},{"location":"installation/","text":"To get started with ntools , you need to install the latest version of 64-bit Git for Windows on your machine, then follow these steps: Open a PowerShell in administrative mode. Assume c:\\source as directory %MainDirectory% which will be used through this document. Clone this repository to your local machine from the %MainDirectory% folder. cd c:\\source git clone https://github.com/naz-hage/ntools Change the PowerShell execution policy to allow the installation script to run. Run the following command: Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope Process This command will allow the installation script to run. Once the installation is complete, the execution policy will revert to its original state. Run the following command to install the ntools: cd c:\\source\\ntools\\dev-setup .\\install.ps1 This command will install the Dotnet Core Desktop runtime and download the ntools from GitHub, installs the ntools package in the %ProgramFiles%\\Nbuild folder, sets up the nTools development environment, adds the %ProgramFiles%\\Nbuild will be added to the system path. After the installation is complete, check out the nbuild.targets for more all the available targets, and navigate to Usage to learn how to execute a build target. ntools is now installed on your machine, and you can start using it to learn how to build and run additional targets . If you have any questions or encounter any issues during the installation process, please don't hesitate to write an an issue . We're here to help!","title":"Installation"},{"location":"msbuild-tasks-test-coverage/","text":"MSBuild Tasks Unit Test Coverage Report Overview Comprehensive unit tests have been implemented for all MSBuild tasks in the NbuildTasks project. The test suite provides robust coverage of functionality, edge cases, and error handling scenarios. Test Projects Structure NbuildTasksTests.csproj Framework : .NET 9.0 Test Framework : MSTest with Moq for mocking Dependencies : Microsoft.NET.Test.Sdk 17.13.0 MSTest.TestAdapter 3.8.3 MSTest.TestFramework 3.8.3 Microsoft.Build.Framework 17.14.8 Microsoft.Build.Utilities.Core 17.14.8 System.Text.Json 9.0.0 Moq 4.20.72 Test Coverage by Task 1. UpdateVersionsInDocs Task Tests File : UpdateVersionsInDocsTests.cs Test Count : 8 tests Test Scenarios: \u2705 Valid JSON and Markdown Processing : Verifies successful version updates with proper JSON files and markdown table \u2705 Invalid JSON File Handling : Ensures task continues processing when encountering malformed JSON \u2705 Missing Markdown File : Validates proper error handling when target markdown file doesn't exist \u2705 Empty Dev Setup Path : Confirms task succeeds even with no JSON files to process \u2705 Incomplete JSON Properties : Tests behavior when JSON files are missing required properties \u2705 Unmatched Tool Names : Verifies tools not in mapping are skipped appropriately \u2705 Multiple Tools Update : Ensures multiple version updates work correctly in a single run \u2705 Markdown Formatting Preservation : Confirms table structure and formatting are maintained Key Features Tested: JSON parsing with error resilience Tool name mapping and matching logic Date formatting and version string handling File I/O operations and error recovery Static readonly mapping performance optimization 2. SetupPreCommitHooks Task Tests File : SetupPreCommitHooksTests.cs Test Count : 8 tests Test Scenarios: \u2705 Valid Directory Setup : Verifies successful hook file copying with proper directory creation \u2705 Existing Hooks Overwrite : Tests that existing hook files are properly replaced \u2705 Empty Source Directory : Ensures task succeeds with empty source directory \u2705 Non-existent Source Directory : Validates proper error handling for missing source \u2705 Invalid Git Directory Path : Tests behavior with invalid destination paths \u2705 Multiple Hook Files : Confirms all hook files are copied correctly \u2705 Hooks Directory Creation : Verifies automatic creation of hooks directory when missing \u2705 Read-only Source Files : Tests copying behavior with read-only source files Key Features Tested: Directory creation and validation File copying with overwrite behavior Error handling for filesystem issues Cross-platform file permissions (theoretical Unix support) Cleanup and resource management 3. GenerateCommitMessage Task Tests File : GenerateCommitMessageTests.cs Test Count : 14 tests Test Scenarios: \u2705 Existing Commit Message File : Verifies task uses content from existing message file \u2705 Custom File Names : Tests support for custom commit message file names \u2705 Dynamic Message Generation : Ensures fallback to generated messages when no file exists \u2705 Custom Commit Types : Validates proper handling of different conventional commit types \u2705 Scope Inclusion : Tests scope parameter integration in commit messages \u2705 Message File Persistence : Confirms generated messages are saved to file \u2705 Whitespace Handling : Verifies proper trimming of file content \u2705 Empty File Handling : Tests behavior with empty or whitespace-only files \u2705 Invalid Working Directory : Ensures graceful degradation with invalid paths \u2705 IO Exception Handling : Tests resilience to file system errors \u2705 Long Message Support : Verifies handling of lengthy commit messages \u2705 Multiline Format Preservation : Tests preservation of complex message formatting \u2705 Generated Message Format : Validates conventional commit format compliance \u2705 Multiple Commit Type Support : Tests various conventional commit types (feat, fix, docs, etc.) Key Features Tested: File-based commit message override Dynamic commit message generation Git status integration and parsing Conventional commit format compliance Error resilience and fallback behavior File I/O operations with error handling Test Infrastructure Features Isolated Test Environment Each test class uses temporary directories to avoid conflicts Proper setup and teardown ensures clean test state Mock IBuildEngine for MSBuild integration testing Error Handling Coverage File system errors (missing files, permission issues) Invalid input data (malformed JSON, invalid paths) Resource cleanup and disposal Graceful degradation scenarios Cross-Platform Considerations Platform-specific file attribute handling Path separator and directory structure handling Git command integration testing Test Execution Results Current Status: \u2705 All Tests Passing Total Tests : 30 Passed : 30 Failed : 0 Skipped : 0 Performance Average Execution Time : ~2 seconds for all MSBuild task tests Resource Usage : Minimal - uses temporary directories and mock objects Benefits of This Test Coverage 1. Reliability Assurance Comprehensive edge case coverage Robust error handling validation Consistent behavior verification 2. Refactoring Safety Changes can be made with confidence Regression detection for future modifications API contract validation 3. Documentation Value Tests serve as executable documentation Clear examples of expected behavior Usage patterns and edge cases demonstrated 4. Debugging Support Isolated test scenarios for issue reproduction Clear test names indicate failure points Detailed assertion messages for troubleshooting Future Enhancements Potential Additions Integration Tests : Full MSBuild pipeline testing Performance Tests : Large-scale file processing benchmarks Parameterized Tests : Data-driven test scenarios Mock Git Integration : Simulated Git repository operations Continuous Improvement Regular test review and updates Coverage analysis and gap identification Performance monitoring and optimization Conclusion The comprehensive unit test suite for the MSBuild tasks provides: - High Confidence in task reliability and correctness - Rapid Feedback for development and debugging - Robust Error Handling for production scenarios - Clear Documentation of expected behavior and edge cases This test infrastructure supports the ongoing development and maintenance of the ntools automation pipeline with confidence and reliability.","title":"MSBuild Tasks Test Coverage"},{"location":"msbuild-tasks-test-coverage/#msbuild-tasks-unit-test-coverage-report","text":"","title":"MSBuild Tasks Unit Test Coverage Report"},{"location":"msbuild-tasks-test-coverage/#overview","text":"Comprehensive unit tests have been implemented for all MSBuild tasks in the NbuildTasks project. The test suite provides robust coverage of functionality, edge cases, and error handling scenarios.","title":"Overview"},{"location":"msbuild-tasks-test-coverage/#test-projects-structure","text":"","title":"Test Projects Structure"},{"location":"msbuild-tasks-test-coverage/#nbuildtaskstestscsproj","text":"Framework : .NET 9.0 Test Framework : MSTest with Moq for mocking Dependencies : Microsoft.NET.Test.Sdk 17.13.0 MSTest.TestAdapter 3.8.3 MSTest.TestFramework 3.8.3 Microsoft.Build.Framework 17.14.8 Microsoft.Build.Utilities.Core 17.14.8 System.Text.Json 9.0.0 Moq 4.20.72","title":"NbuildTasksTests.csproj"},{"location":"msbuild-tasks-test-coverage/#test-coverage-by-task","text":"","title":"Test Coverage by Task"},{"location":"msbuild-tasks-test-coverage/#1-updateversionsindocs-task-tests","text":"File : UpdateVersionsInDocsTests.cs Test Count : 8 tests","title":"1. UpdateVersionsInDocs Task Tests"},{"location":"msbuild-tasks-test-coverage/#test-scenarios","text":"\u2705 Valid JSON and Markdown Processing : Verifies successful version updates with proper JSON files and markdown table \u2705 Invalid JSON File Handling : Ensures task continues processing when encountering malformed JSON \u2705 Missing Markdown File : Validates proper error handling when target markdown file doesn't exist \u2705 Empty Dev Setup Path : Confirms task succeeds even with no JSON files to process \u2705 Incomplete JSON Properties : Tests behavior when JSON files are missing required properties \u2705 Unmatched Tool Names : Verifies tools not in mapping are skipped appropriately \u2705 Multiple Tools Update : Ensures multiple version updates work correctly in a single run \u2705 Markdown Formatting Preservation : Confirms table structure and formatting are maintained","title":"Test Scenarios:"},{"location":"msbuild-tasks-test-coverage/#key-features-tested","text":"JSON parsing with error resilience Tool name mapping and matching logic Date formatting and version string handling File I/O operations and error recovery Static readonly mapping performance optimization","title":"Key Features Tested:"},{"location":"msbuild-tasks-test-coverage/#2-setupprecommithooks-task-tests","text":"File : SetupPreCommitHooksTests.cs Test Count : 8 tests","title":"2. SetupPreCommitHooks Task Tests"},{"location":"msbuild-tasks-test-coverage/#test-scenarios_1","text":"\u2705 Valid Directory Setup : Verifies successful hook file copying with proper directory creation \u2705 Existing Hooks Overwrite : Tests that existing hook files are properly replaced \u2705 Empty Source Directory : Ensures task succeeds with empty source directory \u2705 Non-existent Source Directory : Validates proper error handling for missing source \u2705 Invalid Git Directory Path : Tests behavior with invalid destination paths \u2705 Multiple Hook Files : Confirms all hook files are copied correctly \u2705 Hooks Directory Creation : Verifies automatic creation of hooks directory when missing \u2705 Read-only Source Files : Tests copying behavior with read-only source files","title":"Test Scenarios:"},{"location":"msbuild-tasks-test-coverage/#key-features-tested_1","text":"Directory creation and validation File copying with overwrite behavior Error handling for filesystem issues Cross-platform file permissions (theoretical Unix support) Cleanup and resource management","title":"Key Features Tested:"},{"location":"msbuild-tasks-test-coverage/#3-generatecommitmessage-task-tests","text":"File : GenerateCommitMessageTests.cs Test Count : 14 tests","title":"3. GenerateCommitMessage Task Tests"},{"location":"msbuild-tasks-test-coverage/#test-scenarios_2","text":"\u2705 Existing Commit Message File : Verifies task uses content from existing message file \u2705 Custom File Names : Tests support for custom commit message file names \u2705 Dynamic Message Generation : Ensures fallback to generated messages when no file exists \u2705 Custom Commit Types : Validates proper handling of different conventional commit types \u2705 Scope Inclusion : Tests scope parameter integration in commit messages \u2705 Message File Persistence : Confirms generated messages are saved to file \u2705 Whitespace Handling : Verifies proper trimming of file content \u2705 Empty File Handling : Tests behavior with empty or whitespace-only files \u2705 Invalid Working Directory : Ensures graceful degradation with invalid paths \u2705 IO Exception Handling : Tests resilience to file system errors \u2705 Long Message Support : Verifies handling of lengthy commit messages \u2705 Multiline Format Preservation : Tests preservation of complex message formatting \u2705 Generated Message Format : Validates conventional commit format compliance \u2705 Multiple Commit Type Support : Tests various conventional commit types (feat, fix, docs, etc.)","title":"Test Scenarios:"},{"location":"msbuild-tasks-test-coverage/#key-features-tested_2","text":"File-based commit message override Dynamic commit message generation Git status integration and parsing Conventional commit format compliance Error resilience and fallback behavior File I/O operations with error handling","title":"Key Features Tested:"},{"location":"msbuild-tasks-test-coverage/#test-infrastructure-features","text":"","title":"Test Infrastructure Features"},{"location":"msbuild-tasks-test-coverage/#isolated-test-environment","text":"Each test class uses temporary directories to avoid conflicts Proper setup and teardown ensures clean test state Mock IBuildEngine for MSBuild integration testing","title":"Isolated Test Environment"},{"location":"msbuild-tasks-test-coverage/#error-handling-coverage","text":"File system errors (missing files, permission issues) Invalid input data (malformed JSON, invalid paths) Resource cleanup and disposal Graceful degradation scenarios","title":"Error Handling Coverage"},{"location":"msbuild-tasks-test-coverage/#cross-platform-considerations","text":"Platform-specific file attribute handling Path separator and directory structure handling Git command integration testing","title":"Cross-Platform Considerations"},{"location":"msbuild-tasks-test-coverage/#test-execution-results","text":"","title":"Test Execution Results"},{"location":"msbuild-tasks-test-coverage/#current-status-all-tests-passing","text":"Total Tests : 30 Passed : 30 Failed : 0 Skipped : 0","title":"Current Status: \u2705 All Tests Passing"},{"location":"msbuild-tasks-test-coverage/#performance","text":"Average Execution Time : ~2 seconds for all MSBuild task tests Resource Usage : Minimal - uses temporary directories and mock objects","title":"Performance"},{"location":"msbuild-tasks-test-coverage/#benefits-of-this-test-coverage","text":"","title":"Benefits of This Test Coverage"},{"location":"msbuild-tasks-test-coverage/#1-reliability-assurance","text":"Comprehensive edge case coverage Robust error handling validation Consistent behavior verification","title":"1. Reliability Assurance"},{"location":"msbuild-tasks-test-coverage/#2-refactoring-safety","text":"Changes can be made with confidence Regression detection for future modifications API contract validation","title":"2. Refactoring Safety"},{"location":"msbuild-tasks-test-coverage/#3-documentation-value","text":"Tests serve as executable documentation Clear examples of expected behavior Usage patterns and edge cases demonstrated","title":"3. Documentation Value"},{"location":"msbuild-tasks-test-coverage/#4-debugging-support","text":"Isolated test scenarios for issue reproduction Clear test names indicate failure points Detailed assertion messages for troubleshooting","title":"4. Debugging Support"},{"location":"msbuild-tasks-test-coverage/#future-enhancements","text":"","title":"Future Enhancements"},{"location":"msbuild-tasks-test-coverage/#potential-additions","text":"Integration Tests : Full MSBuild pipeline testing Performance Tests : Large-scale file processing benchmarks Parameterized Tests : Data-driven test scenarios Mock Git Integration : Simulated Git repository operations","title":"Potential Additions"},{"location":"msbuild-tasks-test-coverage/#continuous-improvement","text":"Regular test review and updates Coverage analysis and gap identification Performance monitoring and optimization","title":"Continuous Improvement"},{"location":"msbuild-tasks-test-coverage/#conclusion","text":"The comprehensive unit test suite for the MSBuild tasks provides: - High Confidence in task reliability and correctness - Rapid Feedback for development and debugging - Robust Error Handling for production scenarios - Clear Documentation of expected behavior and edge cases This test infrastructure supports the ongoing development and maintenance of the ntools automation pipeline with confidence and reliability.","title":"Conclusion"},{"location":"nbuild-tasks-integration/","text":"NBuild Tasks Integration Guide This document explains how the new MSBuild tasks have been integrated into the ntools project for automating documentation version updates and pre-commit hook setup. New MSBuild Tasks Added 1. UpdateVersionsInDocs Task Location : NbuildTasks/UpdateVersionsInDocs.cs Purpose : Automatically synchronizes version information from JSON configuration files to the documentation table. Features: Reads all JSON files in the dev-setup/ directory Extracts version information from NbuildAppList[0].Version Updates corresponding entries in the docs/ntools/ntools.md table Handles tool name mapping between JSON and documentation names Updates \"Last Checked on\" dates automatically Provides detailed logging during execution Parameters: DevSetupPath (Required): Path to the directory containing JSON configuration files DocsPath (Required): Path to the markdown documentation file to update 2. SetupPreCommitHooks Task Location : NbuildTasks/UpdateVersionsInDocs.cs Purpose : Automatically installs pre-commit hooks from a source directory to the Git hooks directory. Features: Copies hook files from source directory to .git/hooks/ Makes hook files executable on Unix-like systems Provides logging for installed hooks Parameters: GitDirectory (Required): Path to the Git directory (usually .git ) HooksSourceDirectory (Required): Path to the directory containing hook files Integration with NBuild Project Configuration The tasks have been properly integrated into the NbuildTasks.csproj : <PackageReference Include=\"System.Text.Json\" Version=\"9.0.0\" /> This adds the necessary JSON parsing capabilities to the MSBuild tasks. Target Definitions Two new targets have been added to nbuild.targets : UPDATE_DOC_VERSIONS Target <Target Name=\"UPDATE_DOC_VERSIONS\"> <UpdateVersionsInDocs DevSetupPath=\"$(SolutionDir)\\dev-setup\" DocsPath=\"$(SolutionDir)\\docs\\ntools\\ntools.md\" /> <Message Text=\"Documentation versions updated successfully.\" /> <Message Text=\"==> DONE\"/> </Target> SETUP_HOOKS Target <Target Name=\"SETUP_HOOKS\"> <SetupPreCommitHooks GitDirectory=\"$(SolutionDir)\\.git\" HooksSourceDirectory=\"$(SolutionDir)\\dev-setup\\hooks\" /> <Message Text=\"Pre-commit hooks setup successfully.\" /> <Message Text=\"==> DONE\"/> </Target> Usage Command Line Usage # Update documentation versions dotnet build nbuild.targets -target:UPDATE_DOC_VERSIONS # Setup pre-commit hooks dotnet build nbuild.targets -target:SETUP_HOOKS # Run both tasks dotnet build nbuild.targets -target:UPDATE_DOC_VERSIONS -target:SETUP_HOOKS Integration with Build Process You can integrate these targets into your regular build process by adding dependencies: <Target Name=\"Build\" DependsOnTargets=\"UPDATE_DOC_VERSIONS;SETUP_HOOKS\"> <!-- Your existing build logic --> </Target> Automated CI/CD Integration Add to your GitHub Actions workflow: - name: Update Documentation Versions run: dotnet build nbuild.targets -target:UPDATE_DOC_VERSIONS - name: Commit Updated Documentation run: | git config --local user.email \"action@github.com\" git config --local user.name \"GitHub Action\" git add docs/ntools/ntools.md git diff --staged --quiet || git commit -m \"Auto-update documentation versions\" Tool Name Mapping The UpdateVersionsInDocs task includes intelligent name mapping between JSON configuration names and documentation display names: Documentation Name JSON Configuration Name Node.js Node.js PowerShell Powershell Git for Windows Git for Windows Visual Studio Code Visual Studio Code NuGet Nuget Terraform Lint terraform lint kubernetes kubectl Azure CLI AzureCLI MongoDB Community Server MongoDB (and others...) Benefits 1. Build Integration Native MSBuild tasks run as part of your build process Leverages existing build infrastructure Provides consistent execution environment 2. Performance Compiled C# code executes faster than scripts Integrated with MSBuild's dependency tracking Efficient JSON parsing with System.Text.Json 3. Error Handling Comprehensive error reporting through MSBuild logging Graceful handling of missing files or invalid JSON Clear success/failure indicators 4. Maintainability Centralized logic in the NbuildTasks project Follows established MSBuild patterns Easy to extend with additional functionality Troubleshooting Common Issues Assembly not found errors : Ensure the solution is built in Release mode first Verify NbuildTasks.dll exists in the Release folder Path resolution issues : Check that SolutionDir property is correctly set Verify relative paths resolve correctly from build context JSON parsing errors : Ensure all JSON files in dev-setup are valid Check that JSON files follow the expected NbuildAppList structure Debug Information Enable detailed logging by adding to your build command: dotnet build nbuild.targets -target:UPDATE_DOC_VERSIONS -verbosity:detailed This will show: - Which JSON files are being processed - Which tool versions are found - Which documentation entries are updated - Any warnings or errors encountered Future Enhancements Potential improvements for the tasks: - Validation : Verify that all tools in documentation have corresponding JSON files - Reporting : Generate summary reports of version changes - Configuration : Support for custom mapping files - Integration : Automatic changelog generation based on version changes These MSBuild tasks provide a robust, integrated solution for maintaining documentation consistency within the ntools build system.","title":"NBuild Tasks Integration"},{"location":"nbuild-tasks-integration/#nbuild-tasks-integration-guide","text":"This document explains how the new MSBuild tasks have been integrated into the ntools project for automating documentation version updates and pre-commit hook setup.","title":"NBuild Tasks Integration Guide"},{"location":"nbuild-tasks-integration/#new-msbuild-tasks-added","text":"","title":"New MSBuild Tasks Added"},{"location":"nbuild-tasks-integration/#1-updateversionsindocs-task","text":"Location : NbuildTasks/UpdateVersionsInDocs.cs Purpose : Automatically synchronizes version information from JSON configuration files to the documentation table.","title":"1. UpdateVersionsInDocs Task"},{"location":"nbuild-tasks-integration/#features","text":"Reads all JSON files in the dev-setup/ directory Extracts version information from NbuildAppList[0].Version Updates corresponding entries in the docs/ntools/ntools.md table Handles tool name mapping between JSON and documentation names Updates \"Last Checked on\" dates automatically Provides detailed logging during execution","title":"Features:"},{"location":"nbuild-tasks-integration/#parameters","text":"DevSetupPath (Required): Path to the directory containing JSON configuration files DocsPath (Required): Path to the markdown documentation file to update","title":"Parameters:"},{"location":"nbuild-tasks-integration/#2-setupprecommithooks-task","text":"Location : NbuildTasks/UpdateVersionsInDocs.cs Purpose : Automatically installs pre-commit hooks from a source directory to the Git hooks directory.","title":"2. SetupPreCommitHooks Task"},{"location":"nbuild-tasks-integration/#features_1","text":"Copies hook files from source directory to .git/hooks/ Makes hook files executable on Unix-like systems Provides logging for installed hooks","title":"Features:"},{"location":"nbuild-tasks-integration/#parameters_1","text":"GitDirectory (Required): Path to the Git directory (usually .git ) HooksSourceDirectory (Required): Path to the directory containing hook files","title":"Parameters:"},{"location":"nbuild-tasks-integration/#integration-with-nbuild","text":"","title":"Integration with NBuild"},{"location":"nbuild-tasks-integration/#project-configuration","text":"The tasks have been properly integrated into the NbuildTasks.csproj : <PackageReference Include=\"System.Text.Json\" Version=\"9.0.0\" /> This adds the necessary JSON parsing capabilities to the MSBuild tasks.","title":"Project Configuration"},{"location":"nbuild-tasks-integration/#target-definitions","text":"Two new targets have been added to nbuild.targets :","title":"Target Definitions"},{"location":"nbuild-tasks-integration/#update_doc_versions-target","text":"<Target Name=\"UPDATE_DOC_VERSIONS\"> <UpdateVersionsInDocs DevSetupPath=\"$(SolutionDir)\\dev-setup\" DocsPath=\"$(SolutionDir)\\docs\\ntools\\ntools.md\" /> <Message Text=\"Documentation versions updated successfully.\" /> <Message Text=\"==> DONE\"/> </Target>","title":"UPDATE_DOC_VERSIONS Target"},{"location":"nbuild-tasks-integration/#setup_hooks-target","text":"<Target Name=\"SETUP_HOOKS\"> <SetupPreCommitHooks GitDirectory=\"$(SolutionDir)\\.git\" HooksSourceDirectory=\"$(SolutionDir)\\dev-setup\\hooks\" /> <Message Text=\"Pre-commit hooks setup successfully.\" /> <Message Text=\"==> DONE\"/> </Target>","title":"SETUP_HOOKS Target"},{"location":"nbuild-tasks-integration/#usage","text":"","title":"Usage"},{"location":"nbuild-tasks-integration/#command-line-usage","text":"# Update documentation versions dotnet build nbuild.targets -target:UPDATE_DOC_VERSIONS # Setup pre-commit hooks dotnet build nbuild.targets -target:SETUP_HOOKS # Run both tasks dotnet build nbuild.targets -target:UPDATE_DOC_VERSIONS -target:SETUP_HOOKS","title":"Command Line Usage"},{"location":"nbuild-tasks-integration/#integration-with-build-process","text":"You can integrate these targets into your regular build process by adding dependencies: <Target Name=\"Build\" DependsOnTargets=\"UPDATE_DOC_VERSIONS;SETUP_HOOKS\"> <!-- Your existing build logic --> </Target>","title":"Integration with Build Process"},{"location":"nbuild-tasks-integration/#automated-cicd-integration","text":"Add to your GitHub Actions workflow: - name: Update Documentation Versions run: dotnet build nbuild.targets -target:UPDATE_DOC_VERSIONS - name: Commit Updated Documentation run: | git config --local user.email \"action@github.com\" git config --local user.name \"GitHub Action\" git add docs/ntools/ntools.md git diff --staged --quiet || git commit -m \"Auto-update documentation versions\"","title":"Automated CI/CD Integration"},{"location":"nbuild-tasks-integration/#tool-name-mapping","text":"The UpdateVersionsInDocs task includes intelligent name mapping between JSON configuration names and documentation display names: Documentation Name JSON Configuration Name Node.js Node.js PowerShell Powershell Git for Windows Git for Windows Visual Studio Code Visual Studio Code NuGet Nuget Terraform Lint terraform lint kubernetes kubectl Azure CLI AzureCLI MongoDB Community Server MongoDB (and others...)","title":"Tool Name Mapping"},{"location":"nbuild-tasks-integration/#benefits","text":"","title":"Benefits"},{"location":"nbuild-tasks-integration/#1-build-integration","text":"Native MSBuild tasks run as part of your build process Leverages existing build infrastructure Provides consistent execution environment","title":"1. Build Integration"},{"location":"nbuild-tasks-integration/#2-performance","text":"Compiled C# code executes faster than scripts Integrated with MSBuild's dependency tracking Efficient JSON parsing with System.Text.Json","title":"2. Performance"},{"location":"nbuild-tasks-integration/#3-error-handling","text":"Comprehensive error reporting through MSBuild logging Graceful handling of missing files or invalid JSON Clear success/failure indicators","title":"3. Error Handling"},{"location":"nbuild-tasks-integration/#4-maintainability","text":"Centralized logic in the NbuildTasks project Follows established MSBuild patterns Easy to extend with additional functionality","title":"4. Maintainability"},{"location":"nbuild-tasks-integration/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"nbuild-tasks-integration/#common-issues","text":"Assembly not found errors : Ensure the solution is built in Release mode first Verify NbuildTasks.dll exists in the Release folder Path resolution issues : Check that SolutionDir property is correctly set Verify relative paths resolve correctly from build context JSON parsing errors : Ensure all JSON files in dev-setup are valid Check that JSON files follow the expected NbuildAppList structure","title":"Common Issues"},{"location":"nbuild-tasks-integration/#debug-information","text":"Enable detailed logging by adding to your build command: dotnet build nbuild.targets -target:UPDATE_DOC_VERSIONS -verbosity:detailed This will show: - Which JSON files are being processed - Which tool versions are found - Which documentation entries are updated - Any warnings or errors encountered","title":"Debug Information"},{"location":"nbuild-tasks-integration/#future-enhancements","text":"Potential improvements for the tasks: - Validation : Verify that all tools in documentation have corresponding JSON files - Reporting : Generate summary reports of version changes - Configuration : Support for custom mapping files - Integration : Automatic changelog generation based on version changes These MSBuild tasks provide a robust, integrated solution for maintaining documentation consistency within the ntools build system.","title":"Future Enhancements"},{"location":"pre-commit-setup/","text":"Pre-commit Setup Instructions Method 1: Using Pre-commit Framework (Recommended) Installation # Install pre-commit (requires Python) pip install pre-commit # Install the git hook scripts pre-commit install # Install commit-msg hook pre-commit install --hook-type commit-msg # Test the hooks pre-commit run --all-files Usage # Normal git workflow - hooks run automatically git add . git commit -m \"Your commit message\" # Skip hooks (emergency use only) git commit -m \"Emergency fix\" --no-verify # Run hooks manually pre-commit run # Update hook versions pre-commit autoupdate Method 2: Manual Git Hooks Windows Setup # Make the hook executable (Git Bash or WSL) chmod +x .git/hooks/pre-commit # Or copy the hook file copy dev-setup\\pre-commit-hook.sh .git\\hooks\\pre-commit Test the Hook # Test by modifying a JSON file echo '{\"test\": \"change\"}' > dev-setup/test.json git add dev-setup/test.json git commit -m \"Test commit\" # Hook should run and update documentation Customization Options Skip Specific Hooks # Skip specific hooks SKIP=trailing-whitespace git commit -m \"Skip whitespace check\" # Skip pre-commit framework entirely git commit -m \"Emergency commit\" --no-verify Hook Configuration Edit .pre-commit-config.yaml to: - Add new hooks - Modify existing hook behavior - Set file patterns - Configure stages (commit, push, etc.) Environment Variables # Debug mode export PRE_COMMIT_DEBUG=1 # Colored output export PRE_COMMIT_COLOR=always","title":"Pre-commit Setup"},{"location":"pre-commit-setup/#pre-commit-setup-instructions","text":"","title":"Pre-commit Setup Instructions"},{"location":"pre-commit-setup/#method-1-using-pre-commit-framework-recommended","text":"","title":"Method 1: Using Pre-commit Framework (Recommended)"},{"location":"pre-commit-setup/#installation","text":"# Install pre-commit (requires Python) pip install pre-commit # Install the git hook scripts pre-commit install # Install commit-msg hook pre-commit install --hook-type commit-msg # Test the hooks pre-commit run --all-files","title":"Installation"},{"location":"pre-commit-setup/#usage","text":"# Normal git workflow - hooks run automatically git add . git commit -m \"Your commit message\" # Skip hooks (emergency use only) git commit -m \"Emergency fix\" --no-verify # Run hooks manually pre-commit run # Update hook versions pre-commit autoupdate","title":"Usage"},{"location":"pre-commit-setup/#method-2-manual-git-hooks","text":"","title":"Method 2: Manual Git Hooks"},{"location":"pre-commit-setup/#windows-setup","text":"# Make the hook executable (Git Bash or WSL) chmod +x .git/hooks/pre-commit # Or copy the hook file copy dev-setup\\pre-commit-hook.sh .git\\hooks\\pre-commit","title":"Windows Setup"},{"location":"pre-commit-setup/#test-the-hook","text":"# Test by modifying a JSON file echo '{\"test\": \"change\"}' > dev-setup/test.json git add dev-setup/test.json git commit -m \"Test commit\" # Hook should run and update documentation","title":"Test the Hook"},{"location":"pre-commit-setup/#customization-options","text":"","title":"Customization Options"},{"location":"pre-commit-setup/#skip-specific-hooks","text":"# Skip specific hooks SKIP=trailing-whitespace git commit -m \"Skip whitespace check\" # Skip pre-commit framework entirely git commit -m \"Emergency commit\" --no-verify","title":"Skip Specific Hooks"},{"location":"pre-commit-setup/#hook-configuration","text":"Edit .pre-commit-config.yaml to: - Add new hooks - Modify existing hook behavior - Set file patterns - Configure stages (commit, push, etc.)","title":"Hook Configuration"},{"location":"pre-commit-setup/#environment-variables","text":"# Debug mode export PRE_COMMIT_DEBUG=1 # Colored output export PRE_COMMIT_COLOR=always","title":"Environment Variables"},{"location":"setup/","text":"Setting Up Your Project with dev-setup The dev-setup folder is a critical part of your project setup. It contains scripts and configuration files to automate the installation of development tools and the setup of your development environment. Overview of dev-setup Folder The dev-setup folder typically includes the following files: ntools.json Contains installation information for ntools. This file is required to install ntools before other deveopment tools. apps.json Lists the development tools required for your project, including their installation and uninstallation details. dev-setup.ps1 A PowerShell script that installs the tools listed in apps.json and sets up the development environment. File Details 1. ntools.json This file provides the installation details for ntools, which is required to manage other tools in the project. Example: { \"Version\": \"1.2.0\", \"NbuildAppList\": [ { \"Name\": \"Ntools\", \"Version\": \"1.8.0\", \"AppFileName\": \"$(InstallPath)\\\\nb.exe\", \"WebDownloadFile\": \"https://github.com/naz-hage/ntools/releases/download/$(Version)/$(Version).zip\", \"DownloadedFile\": \"$(Version).zip\", \"InstallCommand\": \"powershell.exe\", \"InstallArgs\": \"-Command Expand-Archive -Path $(Version).zip -DestinationPath '$(InstallPath)' -Force\", \"InstallPath\": \"$(ProgramFiles)\\\\Nbuild\", \"UninstallCommand\": \"powershell.exe\", \"UninstallArgs\": \"-Command Remove-Item -Path '$(InstallPath)' -Recurse -Force\", \"StoredHash\": \"XXX\", \"AddToPath\": true } ] } 2. apps.json This file lists all the development tools required for the project. Each tool is defined with its name, version, installation details, and uninstallation details. Example: { \"Version\": \"1.2.0\", \"NbuildAppList\": [ { \"Name\": \"7-zip\", \"Version\": \"23.01\", \"AppFileName\": \"$(InstallPath)\\\\7z.exe\", \"WebDownloadFile\": \"https://www.7-zip.org/a/7z2301-x64.exe\", \"DownloadedFile\": \"7zip.exe\", \"InstallCommand\": \"$(DownloadedFile)\", \"InstallArgs\": \"/S /D=\\\"$(ProgramFiles)\\\\7-Zip\\\"\", \"InstallPath\": \"$(ProgramFiles)\\\\7-Zip\", \"UninstallCommand\": \"$(InstallPath)\\\\Uninstall.exe\", \"UninstallArgs\": \"/S\" } ] } Key Elements in apps.json: Element Name Description Name The name of the tool. Version The version of the tool. AppFileName The file name of the tool, used to check if it is already installed. WebDownloadFile The URL to download the tool. DownloadedFile The name of the downloaded file, used for installation. InstallCommand The command to install the tool. InstallArgs The arguments for the installation command. InstallPath The location where the tool will be installed. UninstallCommand The command to uninstall the tool. UninstallArgs The arguments for the uninstallation command. StoredHash (Optional) SHA256 hash of the file for verification. AddToPath (Optional) Whether to add the tool's path to the system PATH environment variable. 3. dev-setup.ps1 This PowerShell script automates the installation of tools and sets up the development environment. Key Responsibilities: - Installs ntools using ntools.json. - Installs other tools listed in apps.json. - Verifies administrative privileges before proceeding. Example: # Import the install module $url = \"https://raw.githubusercontent.com/naz-hage/ntools/main/dev-setup/install.psm1\" $output = \"./install.psm1\" Invoke-WebRequest -Uri $url -OutFile $output Import-Module ./install.psm1 -Force # Install Ntools MainInstallApp -command install -json .\\ntools.json if ($LASTEXITCODE -ne 0) { Write-OutputMessage \"Error: Installation of ntools failed. Exiting script.\" exit 1 } # Install other tools & $global:NbExePath install -json .\\apps.json if ($LASTEXITCODE -ne 0) { Write-OutputMessage \"Error: Installation of other tools failed. Exiting script.\" exit 1 } Write-OutputMessage \"Completed installation script.\" Folder Structure Your project folder should look like this: %MainDirectory%\\ \u251c\u2500\u2500 MyProject\\ \u2502 \u251c\u2500\u2500 dev-setup\\ \u2502 \u2502 \u251c\u2500\u2500 ntools.json \u2502 \u2502 \u251c\u2500\u2500 apps.json \u2502 \u2502 \u251c\u2500\u2500 dev-setup.ps1 \u2502 \u251c\u2500\u2500 ... other project and test files \u2502 \u2514\u2500\u2500 nbuild.targets (this file is required in the solution folder) Adding a New Development Tool To add a new tool to your project: 1. Identify the tool's: - Download URL and file name. - Installation and uninstallation commands and arguments. - Installation path. - File name for version checks. - Version and name. 2. Add the tool's details to apps.json. Example for a new tool: { \"Name\": \"Docker\", \"Version\": \"4.38.0.0\", \"AppFileName\": \"$(InstallPath)\\\\Docker Desktop.exe\", \"WebDownloadFile\": \"https://desktop.docker.com/win/main/amd64/Docker%20Desktop%20Installer.exe\", \"DownloadedFile\": \"Docker Desktop Installer.exe\", \"InstallCommand\": \"$(DownloadedFile)\", \"InstallArgs\": \"install --quiet\", \"InstallPath\": \"$(ProgramFiles)\\\\Docker\\\\Docker\", \"UninstallCommand\": \"powershell.exe\", \"UninstallArgs\": \"-Command \\\"Remove-Item -Path '$(InstallPath)' -Recurse -Force\\\"\", \"AddToPath\": true } Notes Error Handling in dev-setup.ps1 : What happens if a tool fails to install? Are there retries or logs generated? Environment Variables: Are there any required environment variables for dev-setup.ps1 to work? Dependencies: Are there any dependencies for the tools listed in apps.json (e.g., PowerShell version)? Testing the Setup: How can users verify that the setup was successful?","title":"Setup your project"},{"location":"setup/#setting-up-your-project-with-dev-setup","text":"The dev-setup folder is a critical part of your project setup. It contains scripts and configuration files to automate the installation of development tools and the setup of your development environment.","title":"Setting Up Your Project with dev-setup"},{"location":"setup/#overview-of-dev-setup-folder","text":"The dev-setup folder typically includes the following files: ntools.json Contains installation information for ntools. This file is required to install ntools before other deveopment tools. apps.json Lists the development tools required for your project, including their installation and uninstallation details. dev-setup.ps1 A PowerShell script that installs the tools listed in apps.json and sets up the development environment.","title":"Overview of dev-setup Folder"},{"location":"setup/#file-details","text":"","title":"File Details"},{"location":"setup/#1-ntoolsjson","text":"This file provides the installation details for ntools, which is required to manage other tools in the project. Example: { \"Version\": \"1.2.0\", \"NbuildAppList\": [ { \"Name\": \"Ntools\", \"Version\": \"1.8.0\", \"AppFileName\": \"$(InstallPath)\\\\nb.exe\", \"WebDownloadFile\": \"https://github.com/naz-hage/ntools/releases/download/$(Version)/$(Version).zip\", \"DownloadedFile\": \"$(Version).zip\", \"InstallCommand\": \"powershell.exe\", \"InstallArgs\": \"-Command Expand-Archive -Path $(Version).zip -DestinationPath '$(InstallPath)' -Force\", \"InstallPath\": \"$(ProgramFiles)\\\\Nbuild\", \"UninstallCommand\": \"powershell.exe\", \"UninstallArgs\": \"-Command Remove-Item -Path '$(InstallPath)' -Recurse -Force\", \"StoredHash\": \"XXX\", \"AddToPath\": true } ] }","title":"1. ntools.json"},{"location":"setup/#2-appsjson","text":"This file lists all the development tools required for the project. Each tool is defined with its name, version, installation details, and uninstallation details. Example: { \"Version\": \"1.2.0\", \"NbuildAppList\": [ { \"Name\": \"7-zip\", \"Version\": \"23.01\", \"AppFileName\": \"$(InstallPath)\\\\7z.exe\", \"WebDownloadFile\": \"https://www.7-zip.org/a/7z2301-x64.exe\", \"DownloadedFile\": \"7zip.exe\", \"InstallCommand\": \"$(DownloadedFile)\", \"InstallArgs\": \"/S /D=\\\"$(ProgramFiles)\\\\7-Zip\\\"\", \"InstallPath\": \"$(ProgramFiles)\\\\7-Zip\", \"UninstallCommand\": \"$(InstallPath)\\\\Uninstall.exe\", \"UninstallArgs\": \"/S\" } ] } Key Elements in apps.json: Element Name Description Name The name of the tool. Version The version of the tool. AppFileName The file name of the tool, used to check if it is already installed. WebDownloadFile The URL to download the tool. DownloadedFile The name of the downloaded file, used for installation. InstallCommand The command to install the tool. InstallArgs The arguments for the installation command. InstallPath The location where the tool will be installed. UninstallCommand The command to uninstall the tool. UninstallArgs The arguments for the uninstallation command. StoredHash (Optional) SHA256 hash of the file for verification. AddToPath (Optional) Whether to add the tool's path to the system PATH environment variable.","title":"2. apps.json"},{"location":"setup/#3-dev-setupps1","text":"This PowerShell script automates the installation of tools and sets up the development environment. Key Responsibilities: - Installs ntools using ntools.json. - Installs other tools listed in apps.json. - Verifies administrative privileges before proceeding. Example: # Import the install module $url = \"https://raw.githubusercontent.com/naz-hage/ntools/main/dev-setup/install.psm1\" $output = \"./install.psm1\" Invoke-WebRequest -Uri $url -OutFile $output Import-Module ./install.psm1 -Force # Install Ntools MainInstallApp -command install -json .\\ntools.json if ($LASTEXITCODE -ne 0) { Write-OutputMessage \"Error: Installation of ntools failed. Exiting script.\" exit 1 } # Install other tools & $global:NbExePath install -json .\\apps.json if ($LASTEXITCODE -ne 0) { Write-OutputMessage \"Error: Installation of other tools failed. Exiting script.\" exit 1 } Write-OutputMessage \"Completed installation script.\"","title":"3. dev-setup.ps1"},{"location":"setup/#folder-structure","text":"Your project folder should look like this: %MainDirectory%\\ \u251c\u2500\u2500 MyProject\\ \u2502 \u251c\u2500\u2500 dev-setup\\ \u2502 \u2502 \u251c\u2500\u2500 ntools.json \u2502 \u2502 \u251c\u2500\u2500 apps.json \u2502 \u2502 \u251c\u2500\u2500 dev-setup.ps1 \u2502 \u251c\u2500\u2500 ... other project and test files \u2502 \u2514\u2500\u2500 nbuild.targets (this file is required in the solution folder)","title":"Folder Structure"},{"location":"setup/#adding-a-new-development-tool","text":"To add a new tool to your project: 1. Identify the tool's: - Download URL and file name. - Installation and uninstallation commands and arguments. - Installation path. - File name for version checks. - Version and name. 2. Add the tool's details to apps.json. Example for a new tool: { \"Name\": \"Docker\", \"Version\": \"4.38.0.0\", \"AppFileName\": \"$(InstallPath)\\\\Docker Desktop.exe\", \"WebDownloadFile\": \"https://desktop.docker.com/win/main/amd64/Docker%20Desktop%20Installer.exe\", \"DownloadedFile\": \"Docker Desktop Installer.exe\", \"InstallCommand\": \"$(DownloadedFile)\", \"InstallArgs\": \"install --quiet\", \"InstallPath\": \"$(ProgramFiles)\\\\Docker\\\\Docker\", \"UninstallCommand\": \"powershell.exe\", \"UninstallArgs\": \"-Command \\\"Remove-Item -Path '$(InstallPath)' -Recurse -Force\\\"\", \"AddToPath\": true }","title":"Adding a New Development Tool"},{"location":"setup/#notes","text":"Error Handling in dev-setup.ps1 : What happens if a tool fails to install? Are there retries or logs generated? Environment Variables: Are there any required environment variables for dev-setup.ps1 to work? Dependencies: Are there any dependencies for the tools listed in apps.json (e.g., PowerShell version)? Testing the Setup: How can users verify that the setup was successful?","title":"Notes"},{"location":"usage/","text":"Once Ntools is installed, Open a Developer Command prompt for Visual Studio 2022 and navigate to your solution folder (i.e. c:\\source\\ntools ). The Nb.exe is the main executable for the Ntools. The following are some examples of how to use the Ntools: Build a solution: Compiles the solution in the solution directory Nb.exe solution Clean a solution: Deletes the release/Debug, bin and obj folders in the solution directory Nb.exe clean Test solution: runs all the tests in the solution Nb.exe test Create a stage release: Creates a stage build which includes the following steps: Clean the solution Build the solution Run tests Create a stage build Publish the stage build Create a zip file of the stage build file Nb.exe stage Display available targets: Lists all the available targets in the targets file Nb.exe targets See the list of available targets at Nbuild Targets","title":"Practice"},{"location":"version-automation-guide/","text":"Documentation Version Automation Guide This document outlines the automation solutions implemented to keep the docs/ntools/ntools.md file synchronized with version information from JSON configuration files in the dev-setup/ directory. Problem Statement The ntools project maintains tool version information in two places: 1. JSON Configuration Files ( dev-setup/*.json ) - Used for automated installation 2. Documentation Table ( docs/ntools/ntools.md ) - User-facing version reference Previously, these had to be updated manually, leading to inconsistencies and outdated documentation. Solutions Implemented We've implemented 4 complementary automation approaches that can be used individually or together: 1. \ud83d\udd27 PowerShell Script Automation What Was Added File : dev-setup/update-versions.ps1 Purpose : Standalone script to sync versions between JSON files and documentation Execution : Manual or triggered by other automation Features Reads all JSON files in dev-setup/ directory Extracts Name and Version from NbuildAppList[0] Updates corresponding entries in ntools.md table Handles tool name mapping (e.g., \"PowerShell\" \u2194 \"Powershell\") Updates \"Last Checked on\" dates automatically Provides colored console output for better UX Usage # Basic usage cd dev-setup .\\update-versions.ps1 # With custom paths .\\update-versions.ps1 -DevSetupPath \"C:\\source\\ntools\\dev-setup\" -DocsPath \"C:\\source\\ntools\\docs\\ntools\\ntools.md\" Benefits \u2705 Immediate execution - Run anytime manually \u2705 Portable - Works on any Windows machine with PowerShell \u2705 Standalone - No dependencies on build system \u2705 Flexible - Can be called from other scripts 2. \ud83c\udfd7\ufe0f NBuild Task Integration What Was Added File : NbuildTasks/UpdateVersionsInDocs.cs Purpose : MSBuild task for build-time automation Execution : Integrated into your existing NBuild workflow Features Native C# MSBuild task implementation JSON parsing using System.Text.Json Regex-based markdown table updating Comprehensive tool name mapping logic Build-time logging and error handling Can be part of CI/CD pipeline Usage <Target Name=\"UpdateDocVersions\"> <UpdateVersionsInDocs DevSetupPath=\"$(MSBuildProjectDirectory)\\dev-setup\" DocsPath=\"$(MSBuildProjectDirectory)\\docs\\ntools\\ntools.md\" /> </Target> Benefits \u2705 Build integration - Automatic during build process \u2705 Native performance - C# execution speed \u2705 MSBuild compatibility - Works with existing build system \u2705 CI/CD ready - Integrates with automated builds 3. \ud83d\udd04 GitHub Actions Workflow What Was Added File : .github/workflows/update-versions.yml Purpose : Automated cloud-based version synchronization Execution : Triggered by changes to JSON files Features Triggers on JSON file changes ( dev-setup/*.json ) Cross-platform execution (Windows runner) Automatic commit and push of documentation updates Pull request integration Manual trigger capability ( workflow_dispatch ) Triggers Push : When JSON files are modified and pushed Pull Request : When JSON files are changed in PRs Manual : Via GitHub Actions UI Benefits \u2705 Zero maintenance - Runs automatically in cloud \u2705 Team collaboration - Works for all contributors \u2705 Version control - Creates traceable commits \u2705 PR integration - Updates docs in pull requests 4. \ud83e\ude9d Git Pre-commit Hooks What Was Added File : .git/hooks/pre-commit (Manual approach) File : .pre-commit-config.yaml (Framework approach) Purpose : Local developer workflow automation Execution : Automatically before each commit Features Manual Hook Features: Detects JSON file changes in staging area Runs PowerShell version update script Automatically stages updated documentation Additional quality checks (debugging code, large files, JSON validation) Colored output with status indicators C# code formatting integration Pre-commit Framework Features: Comprehensive hook ecosystem JSON/YAML validation Code formatting (C#, PowerShell) Conventional commit message validation Configurable and extensible Performance optimized Usage # Manual setup chmod +x .git/hooks/pre-commit # Framework setup pip install pre-commit pre-commit install pre-commit install --hook-type commit-msg # Normal git workflow - hooks run automatically git add . git commit -m \"Update PowerShell version\" Benefits \u2705 Developer workflow - Integrates with daily git usage \u2705 Immediate feedback - Catches issues before commit \u2705 Automatic execution - No manual intervention required \u2705 Quality enforcement - Additional code quality checks Implementation Strategy Recommended Approach Start with PowerShell script - Immediate utility and testing Add pre-commit hooks - Improve developer workflow Integrate with NBuild - Automate in build process Enable GitHub Actions - Complete automation for team Complementary Usage PowerShell Script : Manual updates and testing Pre-commit Hooks : Developer workflow automation NBuild Task : Build-time verification GitHub Actions : Team collaboration and CI/CD Tool Name Mapping The automation handles differences between JSON configuration names and documentation display names: Documentation Name JSON Configuration Name Node.js Node.js PowerShell Powershell Python Python Git for Windows Git for Windows Visual Studio Code Visual Studio Code NuGet Nuget Terraform Terraform Terraform Lint terraform lint kubernetes kubectl minikube minikube Azure CLI AzureCLI MongoDB Community Server MongoDB pnpm pnpm Ntools Ntools Benefits Summary Before Automation \u274c Manual synchronization required \u274c Prone to human error \u274c Inconsistent version information \u274c Time-consuming maintenance \u274c Often forgotten during updates After Automation \u2705 Consistency : Documentation always matches configuration \u2705 Accuracy : Eliminates manual transcription errors \u2705 Efficiency : Saves developer time \u2705 Reliability : Automated processes don't forget \u2705 Scalability : Handles growing number of tools easily \u2705 Auditability : Git history tracks all changes \u2705 Team Collaboration : Works for all team members \u2705 CI/CD Integration : Fits into automated pipelines Maintenance Regular Tasks Monitor automation execution logs Update tool name mappings when new tools are added Review and update hook configurations as needed Test automation after major Git or build system changes Troubleshooting # Test PowerShell script manually cd dev-setup .\\update-versions.ps1 -Verbose # Skip pre-commit hooks if needed git commit --no-verify # Check GitHub Actions logs # Visit: https://github.com/your-repo/actions # Debug pre-commit framework pre-commit run --all-files --verbose Future Enhancements Potential improvements to consider: - Semantic version validation : Ensure versions follow semver - Changelog generation : Auto-update changelogs with version changes - Notification system : Alert team of version updates - Dependency checking : Verify tool compatibility - Release automation : Tag releases when versions change This automation system ensures that the ntools documentation remains accurate and up-to-date with minimal manual intervention, improving both developer productivity and end-user experience.","title":"Documentation Version Automation Guide"},{"location":"version-automation-guide/#documentation-version-automation-guide","text":"This document outlines the automation solutions implemented to keep the docs/ntools/ntools.md file synchronized with version information from JSON configuration files in the dev-setup/ directory.","title":"Documentation Version Automation Guide"},{"location":"version-automation-guide/#problem-statement","text":"The ntools project maintains tool version information in two places: 1. JSON Configuration Files ( dev-setup/*.json ) - Used for automated installation 2. Documentation Table ( docs/ntools/ntools.md ) - User-facing version reference Previously, these had to be updated manually, leading to inconsistencies and outdated documentation.","title":"Problem Statement"},{"location":"version-automation-guide/#solutions-implemented","text":"We've implemented 4 complementary automation approaches that can be used individually or together:","title":"Solutions Implemented"},{"location":"version-automation-guide/#1-powershell-script-automation","text":"","title":"1. \ud83d\udd27 PowerShell Script Automation"},{"location":"version-automation-guide/#what-was-added","text":"File : dev-setup/update-versions.ps1 Purpose : Standalone script to sync versions between JSON files and documentation Execution : Manual or triggered by other automation","title":"What Was Added"},{"location":"version-automation-guide/#features","text":"Reads all JSON files in dev-setup/ directory Extracts Name and Version from NbuildAppList[0] Updates corresponding entries in ntools.md table Handles tool name mapping (e.g., \"PowerShell\" \u2194 \"Powershell\") Updates \"Last Checked on\" dates automatically Provides colored console output for better UX","title":"Features"},{"location":"version-automation-guide/#usage","text":"# Basic usage cd dev-setup .\\update-versions.ps1 # With custom paths .\\update-versions.ps1 -DevSetupPath \"C:\\source\\ntools\\dev-setup\" -DocsPath \"C:\\source\\ntools\\docs\\ntools\\ntools.md\"","title":"Usage"},{"location":"version-automation-guide/#benefits","text":"\u2705 Immediate execution - Run anytime manually \u2705 Portable - Works on any Windows machine with PowerShell \u2705 Standalone - No dependencies on build system \u2705 Flexible - Can be called from other scripts","title":"Benefits"},{"location":"version-automation-guide/#2-nbuild-task-integration","text":"","title":"2. \ud83c\udfd7\ufe0f NBuild Task Integration"},{"location":"version-automation-guide/#what-was-added_1","text":"File : NbuildTasks/UpdateVersionsInDocs.cs Purpose : MSBuild task for build-time automation Execution : Integrated into your existing NBuild workflow","title":"What Was Added"},{"location":"version-automation-guide/#features_1","text":"Native C# MSBuild task implementation JSON parsing using System.Text.Json Regex-based markdown table updating Comprehensive tool name mapping logic Build-time logging and error handling Can be part of CI/CD pipeline","title":"Features"},{"location":"version-automation-guide/#usage_1","text":"<Target Name=\"UpdateDocVersions\"> <UpdateVersionsInDocs DevSetupPath=\"$(MSBuildProjectDirectory)\\dev-setup\" DocsPath=\"$(MSBuildProjectDirectory)\\docs\\ntools\\ntools.md\" /> </Target>","title":"Usage"},{"location":"version-automation-guide/#benefits_1","text":"\u2705 Build integration - Automatic during build process \u2705 Native performance - C# execution speed \u2705 MSBuild compatibility - Works with existing build system \u2705 CI/CD ready - Integrates with automated builds","title":"Benefits"},{"location":"version-automation-guide/#3-github-actions-workflow","text":"","title":"3. \ud83d\udd04 GitHub Actions Workflow"},{"location":"version-automation-guide/#what-was-added_2","text":"File : .github/workflows/update-versions.yml Purpose : Automated cloud-based version synchronization Execution : Triggered by changes to JSON files","title":"What Was Added"},{"location":"version-automation-guide/#features_2","text":"Triggers on JSON file changes ( dev-setup/*.json ) Cross-platform execution (Windows runner) Automatic commit and push of documentation updates Pull request integration Manual trigger capability ( workflow_dispatch )","title":"Features"},{"location":"version-automation-guide/#triggers","text":"Push : When JSON files are modified and pushed Pull Request : When JSON files are changed in PRs Manual : Via GitHub Actions UI","title":"Triggers"},{"location":"version-automation-guide/#benefits_2","text":"\u2705 Zero maintenance - Runs automatically in cloud \u2705 Team collaboration - Works for all contributors \u2705 Version control - Creates traceable commits \u2705 PR integration - Updates docs in pull requests","title":"Benefits"},{"location":"version-automation-guide/#4-git-pre-commit-hooks","text":"","title":"4. \ud83e\ude9d Git Pre-commit Hooks"},{"location":"version-automation-guide/#what-was-added_3","text":"File : .git/hooks/pre-commit (Manual approach) File : .pre-commit-config.yaml (Framework approach) Purpose : Local developer workflow automation Execution : Automatically before each commit","title":"What Was Added"},{"location":"version-automation-guide/#features_3","text":"","title":"Features"},{"location":"version-automation-guide/#manual-hook-features","text":"Detects JSON file changes in staging area Runs PowerShell version update script Automatically stages updated documentation Additional quality checks (debugging code, large files, JSON validation) Colored output with status indicators C# code formatting integration","title":"Manual Hook Features:"},{"location":"version-automation-guide/#pre-commit-framework-features","text":"Comprehensive hook ecosystem JSON/YAML validation Code formatting (C#, PowerShell) Conventional commit message validation Configurable and extensible Performance optimized","title":"Pre-commit Framework Features:"},{"location":"version-automation-guide/#usage_2","text":"# Manual setup chmod +x .git/hooks/pre-commit # Framework setup pip install pre-commit pre-commit install pre-commit install --hook-type commit-msg # Normal git workflow - hooks run automatically git add . git commit -m \"Update PowerShell version\"","title":"Usage"},{"location":"version-automation-guide/#benefits_3","text":"\u2705 Developer workflow - Integrates with daily git usage \u2705 Immediate feedback - Catches issues before commit \u2705 Automatic execution - No manual intervention required \u2705 Quality enforcement - Additional code quality checks","title":"Benefits"},{"location":"version-automation-guide/#implementation-strategy","text":"","title":"Implementation Strategy"},{"location":"version-automation-guide/#recommended-approach","text":"Start with PowerShell script - Immediate utility and testing Add pre-commit hooks - Improve developer workflow Integrate with NBuild - Automate in build process Enable GitHub Actions - Complete automation for team","title":"Recommended Approach"},{"location":"version-automation-guide/#complementary-usage","text":"PowerShell Script : Manual updates and testing Pre-commit Hooks : Developer workflow automation NBuild Task : Build-time verification GitHub Actions : Team collaboration and CI/CD","title":"Complementary Usage"},{"location":"version-automation-guide/#tool-name-mapping","text":"The automation handles differences between JSON configuration names and documentation display names: Documentation Name JSON Configuration Name Node.js Node.js PowerShell Powershell Python Python Git for Windows Git for Windows Visual Studio Code Visual Studio Code NuGet Nuget Terraform Terraform Terraform Lint terraform lint kubernetes kubectl minikube minikube Azure CLI AzureCLI MongoDB Community Server MongoDB pnpm pnpm Ntools Ntools","title":"Tool Name Mapping"},{"location":"version-automation-guide/#benefits-summary","text":"","title":"Benefits Summary"},{"location":"version-automation-guide/#before-automation","text":"\u274c Manual synchronization required \u274c Prone to human error \u274c Inconsistent version information \u274c Time-consuming maintenance \u274c Often forgotten during updates","title":"Before Automation"},{"location":"version-automation-guide/#after-automation","text":"\u2705 Consistency : Documentation always matches configuration \u2705 Accuracy : Eliminates manual transcription errors \u2705 Efficiency : Saves developer time \u2705 Reliability : Automated processes don't forget \u2705 Scalability : Handles growing number of tools easily \u2705 Auditability : Git history tracks all changes \u2705 Team Collaboration : Works for all team members \u2705 CI/CD Integration : Fits into automated pipelines","title":"After Automation"},{"location":"version-automation-guide/#maintenance","text":"","title":"Maintenance"},{"location":"version-automation-guide/#regular-tasks","text":"Monitor automation execution logs Update tool name mappings when new tools are added Review and update hook configurations as needed Test automation after major Git or build system changes","title":"Regular Tasks"},{"location":"version-automation-guide/#troubleshooting","text":"# Test PowerShell script manually cd dev-setup .\\update-versions.ps1 -Verbose # Skip pre-commit hooks if needed git commit --no-verify # Check GitHub Actions logs # Visit: https://github.com/your-repo/actions # Debug pre-commit framework pre-commit run --all-files --verbose","title":"Troubleshooting"},{"location":"version-automation-guide/#future-enhancements","text":"Potential improvements to consider: - Semantic version validation : Ensure versions follow semver - Changelog generation : Auto-update changelogs with version changes - Notification system : Alert team of version updates - Dependency checking : Verify tool compatibility - Release automation : Tag releases when versions change This automation system ensures that the ntools documentation remains accurate and up-to-date with minimal manual intervention, improving both developer productivity and end-user experience.","title":"Future Enhancements"},{"location":"versioning/","text":"Version and Tag Throughout this document, the terms \"version\" and \"tag\" are used interchangeably. The version applies to binaries, product, or repo tagging. The rules for ntools versioning are as follows: The version is a string in the format of X.Y.Z , where X , Y , and Z are integers. The version is incremented as follows: X is the major number: Incremented for breaking changes. Y is the minor number: Incremented for new features or bug fixes. Incremented when production Build Type is deployed. Incrementing Y resets Z to 0. Z is the build number: Incremented when staging Build Type is deployed. Tags in the GitHubRelease are used to: Identify specific versions of the repository. Associate release assets with a particular version. Generate release notes based on commits since the last tag.","title":"Versioning"},{"location":"versioning/#version-and-tag","text":"Throughout this document, the terms \"version\" and \"tag\" are used interchangeably. The version applies to binaries, product, or repo tagging. The rules for ntools versioning are as follows: The version is a string in the format of X.Y.Z , where X , Y , and Z are integers. The version is incremented as follows: X is the major number: Incremented for breaking changes. Y is the minor number: Incremented for new features or bug fixes. Incremented when production Build Type is deployed. Incrementing Y resets Z to 0. Z is the build number: Incremented when staging Build Type is deployed. Tags in the GitHubRelease are used to: Identify specific versions of the repository. Associate release assets with a particular version. Generate release notes based on commits since the last tag.","title":"Version and Tag"},{"location":"ntools/devsetup/","text":"Content of dev-setup.ps1: This script sets up the development environment for your project, installs ntools and the necessary development tools, and sets the development environment variables. # dev-setup.ps1 # Get the common Install module and import it $url = \"https://raw.githubusercontent.com/naz-hage/ntools/main/dev-setup/install.psm1\" $output = \"./install.psm1\" Invoke-WebRequest -Uri $url -OutFile $output Import-Module ./install.psm1 -Force $fileName = Split-Path -Leaf $PSCommandPath Write-OutputMessage $fileName \"Started installation script.\" # Check if the script is running with admin rights if (-NOT ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] \"Administrator\")) { Write-OutputMessage $fileName \"Error: Please run this script as an administrator.\" exit 1 } else { Write-OutputMessage $fileName \"Admin rights detected\" } # Install Ntools MainInstallApp -command install -json .\\app-Ntools.json if ($LASTEXITCODE -ne 0) { Write-OutputMessage $fileName \"Error: Installation of ntools (app-Ntools.json) failed. Exiting script.\" exit 1 } # Install development tools for the project & $global:NbExePath install -json .\\apps.json if ($LASTEXITCODE -ne 0) { Write-OutputMessage $fileName \"Error: Installation of other tools (apps.json) failed. Exiting script.\" exit 1 } Write-OutputMessage $fileName \"Completed installation script.\" Write-OutputMessage $fileName \"EmtpyLine\"","title":"Devsetup"},{"location":"ntools/github-release/","text":"Nb.exe is also designed to help you create and manage GitHub releases. It also enables you to download release assets, such as files named in the format x.y.z.zip. The tool expects downloaded assets to be in a zip file named ${tag}.zip, where tag must be a valid tag in the repository created by the tool (e.g., x.y.z ). checkout the tagging section for more details. Requirements Repository Requirements The repository must have: A GitHub token to create releases. A GitHub owner to create releases. A Git branch to create releases. At least one Git tag prior to creating releases. Environment Requirements The GitHub API token (Required) and repository owner (Optional) are obtained from environment variables: OWNER : The GitHub repository owner's username. The owner is optional and can be specified in the command line with -repo option. Checkout usage below. API_GITHUB_KEY : The GitHub API token (personal access token). Local development with Windows Platforms: For additional security, the GitHub API token should be saved in the Windows Credential Manager with: Target Name: GitHubRelease Credential Name: API_GITHUB_KEY GitHub Actions Workflow Example Here is an example of how to set up the required environment variables in a GitHub Actions workflow file: - name: Build using ntools run: | & \"$env:ProgramFilesPath/nbuild/nb.exe\" ${{ env.Build_Type }} -v ${{ env.Enable_Logging }} shell: pwsh working-directory: ${{ github.workspace }} env: OWNER: ${{ github.repository_owner }} API_GITHUB_KEY: ${{ secrets.API_GITHUB_KEY }} The above action builds, test, and creates a release using the GitHubRelease tool and upload to GitHub. Branch Checkout Example Before running the tool, you must checkout a branch. Here is an example of how to checkout a branch in a GitHub Actions workflow file: - name: Checkout Repository uses: actions/checkout@v4 with: token: ${{ secrets.API_GITHUB_KEY }} fetch-depth: 0 ref: ${{ github.event.pull_request.head.ref }} repository: ${{ github.event.pull_request.head.repo.full_name }} Release Process Stage Release When nb stage runs successfully: The tool creates a stage release tagged with the next stage release number. The release notes include the commits since the last stage or production tag. The API token from the repository secrets is used to create this release. The release package is uploaded to the release. Production Release When nb prod runs successfully: The tool creates a production release tagged with the next production release number. The release notes include the commits since the last production tag. All previous stage releases are deleted. The API token from the repository secrets is used to create this release. The release package is uploaded to the release. Create a GitHub Token Follow the GitHub documentation to create a GitHub token. Required Permissions The access token must have the following permissions: Permission Type Scope Description Repository Contents: Read/Write Access repository contents. Metadata: Read-only Access repository metadata. Actions: Read/Write Manage GitHub Actions (if needed). Packages: Read/Write Manage GitHub Packages (if needed). Workflow Workflows: Read/Write Manage workflows (if needed). Release Releases: Read/Write Manage GitHub releases. GitHubRelease Command Line Options Usage See nb.exe for the command line options.","title":"Github Release"},{"location":"ntools/github-release/#requirements","text":"","title":"Requirements"},{"location":"ntools/github-release/#repository-requirements","text":"The repository must have: A GitHub token to create releases. A GitHub owner to create releases. A Git branch to create releases. At least one Git tag prior to creating releases.","title":"Repository Requirements"},{"location":"ntools/github-release/#environment-requirements","text":"The GitHub API token (Required) and repository owner (Optional) are obtained from environment variables: OWNER : The GitHub repository owner's username. The owner is optional and can be specified in the command line with -repo option. Checkout usage below. API_GITHUB_KEY : The GitHub API token (personal access token). Local development with Windows Platforms: For additional security, the GitHub API token should be saved in the Windows Credential Manager with: Target Name: GitHubRelease Credential Name: API_GITHUB_KEY","title":"Environment Requirements"},{"location":"ntools/github-release/#github-actions-workflow-example","text":"Here is an example of how to set up the required environment variables in a GitHub Actions workflow file: - name: Build using ntools run: | & \"$env:ProgramFilesPath/nbuild/nb.exe\" ${{ env.Build_Type }} -v ${{ env.Enable_Logging }} shell: pwsh working-directory: ${{ github.workspace }} env: OWNER: ${{ github.repository_owner }} API_GITHUB_KEY: ${{ secrets.API_GITHUB_KEY }} The above action builds, test, and creates a release using the GitHubRelease tool and upload to GitHub.","title":"GitHub Actions Workflow Example"},{"location":"ntools/github-release/#branch-checkout-example","text":"Before running the tool, you must checkout a branch. Here is an example of how to checkout a branch in a GitHub Actions workflow file: - name: Checkout Repository uses: actions/checkout@v4 with: token: ${{ secrets.API_GITHUB_KEY }} fetch-depth: 0 ref: ${{ github.event.pull_request.head.ref }} repository: ${{ github.event.pull_request.head.repo.full_name }}","title":"Branch Checkout Example"},{"location":"ntools/github-release/#release-process","text":"","title":"Release Process"},{"location":"ntools/github-release/#stage-release","text":"When nb stage runs successfully: The tool creates a stage release tagged with the next stage release number. The release notes include the commits since the last stage or production tag. The API token from the repository secrets is used to create this release. The release package is uploaded to the release.","title":"Stage Release"},{"location":"ntools/github-release/#production-release","text":"When nb prod runs successfully: The tool creates a production release tagged with the next production release number. The release notes include the commits since the last production tag. All previous stage releases are deleted. The API token from the repository secrets is used to create this release. The release package is uploaded to the release.","title":"Production Release"},{"location":"ntools/github-release/#create-a-github-token","text":"Follow the GitHub documentation to create a GitHub token.","title":"Create a GitHub Token"},{"location":"ntools/github-release/#required-permissions","text":"The access token must have the following permissions: Permission Type Scope Description Repository Contents: Read/Write Access repository contents. Metadata: Read-only Access repository metadata. Actions: Read/Write Manage GitHub Actions (if needed). Packages: Read/Write Manage GitHub Packages (if needed). Workflow Workflows: Read/Write Manage workflows (if needed). Release Releases: Read/Write Manage GitHub releases.","title":"Required Permissions"},{"location":"ntools/github-release/#githubrelease-command-line-options","text":"","title":"GitHubRelease Command Line Options"},{"location":"ntools/github-release/#usage","text":"See nb.exe for the command line options.","title":"Usage"},{"location":"ntools/lf/","text":"lf: File and Folder Listing Utility lf is a command-line tool for listing files and folders in a directory tree, with flexible filtering options. It is built using System.CommandLine and is part of the ntools suite. Features List files by extension, recursively. List folders containing specified names, recursively. Simple, fast, and scriptable. Commands 1. files Lists files with specified extensions in a directory (recursively). Options: - -d , --directoryPath Directory path to search in (default: current directory) - -e , --extensions Comma-separated file extensions (default: .yml,.yaml ) Example: lf files -d C:\\Projects -e .cs,.md This command will list all .cs and .md files in the C:\\Projects directory and its subdirectories. 2. folders Lists folders containing specified names in a directory (recursively). Options: - -d , --directoryPath Directory path to search in (default: current directory) - -n , --name Comma-separated list of folder names to search for Example: lf folders -d C:\\Projects -n bin,obj This command will list all folders named bin and obj in the C:\\Projects directory and its subdirectories.","title":"lf (lf.exe)"},{"location":"ntools/lf/#lf-file-and-folder-listing-utility","text":"lf is a command-line tool for listing files and folders in a directory tree, with flexible filtering options. It is built using System.CommandLine and is part of the ntools suite.","title":"lf: File and Folder Listing Utility"},{"location":"ntools/lf/#features","text":"List files by extension, recursively. List folders containing specified names, recursively. Simple, fast, and scriptable.","title":"Features"},{"location":"ntools/lf/#commands","text":"","title":"Commands"},{"location":"ntools/lf/#1-files","text":"Lists files with specified extensions in a directory (recursively). Options: - -d , --directoryPath Directory path to search in (default: current directory) - -e , --extensions Comma-separated file extensions (default: .yml,.yaml ) Example: lf files -d C:\\Projects -e .cs,.md This command will list all .cs and .md files in the C:\\Projects directory and its subdirectories.","title":"1. files"},{"location":"ntools/lf/#2-folders","text":"Lists folders containing specified names in a directory (recursively). Options: - -d , --directoryPath Directory path to search in (default: current directory) - -n , --name Comma-separated list of folder names to search for Example: lf folders -d C:\\Projects -n bin,obj This command will list all folders named bin and obj in the C:\\Projects directory and its subdirectories.","title":"2. folders"},{"location":"ntools/nbackup/","text":"Nbackup ( nbackup.exe ) is a tool that leverages robocopy to backup a list of files and folders from a source to a destination. It is designed to be reliable and efficient, ensuring that your data is safe. Usage Nbackup.exe [-i value] [-e value] [-v value] [-performbackup value] - i : input json file which specifies source, destination and backup options. (string, default=) - e : Extract input json example file to current directory. (string, default=) - v : Verbose level (true or false, default=False) - performbackup : Set to false to verify json file without backup (true or false, default=True) A sample json file is provided below: { \"BackupsList\": [ { \"Source\": \".\", \"Destination\": \"%APPDATA%\\\\ntools\", \"ExcludeFolders\": [ \".git\", \".vs\" ], \"ExcludeFiles\": [ \"*.exe\", \"*.dll\", \"*.pdb\" ], \"LogFile\": \"%APPDATA%\\\\backup.log\", \"BackupOptions\": \"/V /R:5 /W:5 /MT:16 /dcopy:DAT /copy:DT\" } ] }","title":"Nbackup (nbackup.exe)"},{"location":"ntools/nbackup/#usage","text":"Nbackup.exe [-i value] [-e value] [-v value] [-performbackup value] - i : input json file which specifies source, destination and backup options. (string, default=) - e : Extract input json example file to current directory. (string, default=) - v : Verbose level (true or false, default=False) - performbackup : Set to false to verify json file without backup (true or false, default=True) A sample json file is provided below: { \"BackupsList\": [ { \"Source\": \".\", \"Destination\": \"%APPDATA%\\\\ntools\", \"ExcludeFolders\": [ \".git\", \".vs\" ], \"ExcludeFiles\": [ \"*.exe\", \"*.dll\", \"*.pdb\" ], \"LogFile\": \"%APPDATA%\\\\backup.log\", \"BackupOptions\": \"/V /R:5 /W:5 /MT:16 /dcopy:DAT /copy:DT\" } ] }","title":"Usage"},{"location":"ntools/nbuild-targets/","text":"The table below lists all available targets for the Nbuild tool. C:\\source\\ntools\\nbuild.targets Targets Target Name Description ARTIFACTS Setup the ARTIFACTS folders for binaries and test results - override FILE_VERSIONS Test for FileVersion task and powershell file-version.ps1 NBUILD_DOWNLOAD Download Nbuild specified in the NbuildTargetVersion NBUILD_INSTALL Install Nbuild specified in the NbuildTargetVersion DEV_SETUP Setup Development Environment MKDOCS Build docs locally for testing MKDOCS_DEPLOY mkdocs deploy locally GET_PRODUCT_CODES Example to get the installation Product code used for uninstallation of product CORE Display core properties UPDATE_NTOOLS Update ntools locally for testing NUGET_UPDATE Update the ntools-launcher nuget package in the local feed for testing - not needed for normal builds YELLOW_MESSAGE Example of a target that displays a yellow color message RED_MESSAGE Example of a target that displays a red color message GITHUB_RELEASE Creates a stage or prod release GITHUB_PRE_RELEASE Creates a stage or prod pre-release INSTALL_DOTNET_OUTDATED_TOOL Install dotnet-outdated-tool globally UPDATE_NUGET_PACKAGES Update all NuGet packages to the latest version LIST_NUGET_SOURCES List all NuGet sources UPDATE_DOC_VERSIONS Update documentation versions from JSON configuration files SETUP_HOOKS GENERATE_COMMIT_MESSAGE Intelligent commit message generation GIT_COMMIT_INFRASTRUCTURE Automated Git commit with intelligent message generation UPDATE_AND_COMMIT Combined target: Update versions and commit with smart message INFRASTRUCTURE_COMMIT Full infrastructure update and commit with intelligent analysis PREVIEW_COMMIT_MESSAGE Preview commit message without committing C:\\Program Files\\Nbuild\\common.targets Targets Target Name Description PROPERTIES Common properties that will be used by all targets CLEAN Clean up the project and artifacts folder INSTALL_DEP Install dependencies TELEMETRY_OPT_OUT Opt out of the DOTNET_CLI_TELEMETRY_OPTOUT - move to common DEV Create a development package for testing without incrementing the version STAGE Create a stage package for testing PROD Create a PROD package for release GITHUB_RELEASE Creates a stage or prod release GITHUB_PRE_RELEASE Creates a stage or prod pre-release STAGE_DEPLOY Create a STAGE package and deploy for testing PROD_DEPLOY Create a PROD package and deploy for release SOLUTION Build the solution Release configuration using dotnet build SOLUTION_MSBUILD Build the solution Release configuration using MSBuild PACKAGE Create a package for the solution default is a zip file of all artifacts COPY_ARTIFACTS Save the artifacts to the artifacts folder DEPLOY Deploy the package. default is to extract artifacts into DeploymentProperty folder TEST Run all tests using dotnet test in Release mode TEST_DEBUG Run all tests using dotnet test in Debug mode IS_ADMIN Check if current process is running in admin mode AdminCheckExitCode property is set SingleProject Example how to build a single project HandleError Error handling placeholder C:\\Program Files\\nbuild\\apps-versions.targets Targets Target Name Description APP_COMMON Defines the download location for the apps C:\\Program Files\\nbuild\\git.targets Targets Target Name Description GIT_DOWNLOAD Download Git For Windows version specified in GitTargetVersion - Requires admin mode GIT_INSTALL Download Git For Windows version specified in GitTargetVersion property and install GIT_UPDATE Update the current Git for Windows C:\\Program Files\\nbuild\\dotnet.targets Targets Target Name Description DOTNET_SDK_DOWNLOAD Download dotnet Core sdk DOTNET_SDK_INSTALL Download and install dotnet Core sdk DOTNET_DOWNLOAD Download DotNet Core DOTNET_INSTALL Download and install DotNet Core C:\\Program Files\\nbuild\\code.targets Targets Target Name Description CODE_DOWNLOAD Download node version specified in CodeTargetVersion - Requires admin mode CODE_INSTALL Download node version specified in CodeTargetVersion property and install C:\\Program Files\\nbuild\\node.targets Targets Target Name Description NODE_DOWNLOAD Download node version specified in NodeTargetVersion - Requires admin mode NODE_INSTALL Download node version specified in NodeTargetVersion property and install NODE_VERSION Display the installed note version C:\\Program Files\\nbuild\\mongodb.targets Targets Target Name Description MONGODB_INSTALL Display mongodb version specified in TargetNodeVersion property and install C:\\Program Files\\nbuild\\nuget.targets Targets Target Name Description NUGET_VERSION Display the installed nuget version NUGET_INSTALL Download latest nuget.exe and install C:\\Program Files\\nbuild\\ngit.targets Targets Target Name Description GIT_STATUS Display the current git status AUTOTAG_STAGE Increment version for a stage build SET_TAG Set version for a stage build GIT_PULL Get the latest tag from git AUTOTAG_PROD Increment version for a production build TAG Get the tag from git PUSH_TAG Push the tag to the remote repo GIT_BRANCH Get the current git branch C:\\Program Files\\nbuild\\docker.targets Targets Target Name Description DOCKER_DOWNLOAD Download Docker version specified in DockerTargetVersion - Requires admin mode DOCKER_INSTALL Download Docker version specified in DockerTargetVersion property and install C:\\Program Files\\nbuild\\terraform.targets Targets Target Name Description TF_WORKSPACE Create a new terraform workspace dev and select it TF_INIT Init terraform TF_PLAN terraform plan TF_APPLY terraform apply TF_DESTROY terraform destroy","title":"Nbuild targets"},{"location":"ntools/nbuild/","text":"Usage nbuild.targets common.targets Examples Nbuild Nbuild ( nb.exe ) is a wrapper for MSBuild that simplifies building solutions and provides a way to define and run custom targets. Nb.exe is also a command line tool that installs the development tools and run times required to build and test any solution. To build a target type Nb.exe [Target Name] The list of targets is generated by running the Nb.exe targets command. Nb.exe expects the nbuild.targets file to be present in the solution folder. Below is a full list of options that can be used with Nb.exe : Usage Nb.exe command [-json value] [-v value] [-url value] [-tag value] [-path value] [-buildtype value] [-repo value] [-branch value] [-file value] - command : Specifies the command to execute. list -> Lists apps specified in the -json option. install -> Downloads and installs apps specified in the -json option (requires admin privileges). uninstall -> Uninstalls apps specified in the -json option (requires admin privileges). download -> Downloads tools or apps listed in the -json option (requires admin privileges). targets -> Lists available build targets and saves them in the targets.md file. path -> Displays the environment PATH variable for the local machine. git_info -> Displays the current git information for the local repository. git_settag -> Sets the specified tag using the -tag option. git_autotag -> Sets the next tag based on the build type: STAGE or PROD. git_push_autotag -> Sets the next tag based on the build type and pushes to the remote repository. git_branch -> Displays the current git branch in the local repository. git_clone -> Clones the specified Git repository using the -url option. git_deletetag -> Deletes the specified tag using the -tag option. release_create -> Creates a GitHub release. Requires -repo, -tag, -branch, and -file options. pre_release_create -> Creates a GitHub pre-release. Requires -repo, -tag, -branch, and -file options. release_download -> Downloads a specific asset from a GitHub release. Requires -repo, -tag, and -path (optional, defaults to current directory). list_release -> Lists latest 3 releases for the specified repository (and latest pre-release if newer). Requires -repo. ---- The nbuild.exe can also execute targets defined in an nbuild.targets file if one exists in the current folder. To execute a target defined in nbuild.targets, simply use its name as the command. For example, if nbuild.targets defines a target named 'build', you can run it with: `nb.exe build` (one of list,install,uninstall,download,targets,path,git_info,git_settag,git_autotag,git_push_autotag,git_branch,git_clone,git_deletetag,release_create,pre_release_create,release_download,list_release, required) - json : Specifies the JSON file that holds the list of apps. Only valid for the install, download, and list commands. - By default, the -json option points to the ntools deployment folder: $(ProgramFiles)\\build\\ntools.json. Sample JSON file: https://github.com/naz-hage/ntools/blob/main/dev-setup/ntools.json (string, default=$(ProgramFiles)\\nbuild\\ntools.json) - v : Optional parameter which sets the console output verbose level ---- - if no command line options are specified with the -v option , i.e.: 'Nb.exe stage -v true` `Nb` will run an MSbuild target `stage` defined in a `nbuild.targets` file which present in the solution folder. Run `Nb.exe Targets` to list the available targets. -v Possible Values: (true or false, default=False) - url : Specifies the Git repository URL. (string, default=) - tag : Specifies the tag used for git_settag and git_deletetag commands. (string, default=) - path : Specifies the path used for git_clone, pre_release_create and release_create commands. If not specified, the current directory will be used. for pre_release_create and release_create commands, it must be an absolute path (string, default=) - buildtype : Specifies the build type used for git_autotag and git_push_autotag commands. Possible values: STAGE, PROD. (string, default=) - repo : Specifies the Git repository in the format any of the following formats: repoName (UserName is declared the `OWNER` environment variable) userName/repoName https://github.com/userName/repoName (Full URL to the repository on GitHub). This is applicable to release_create, pre_release_create and release_download commands. (string, default=) - branch : Specifies the branch name. Applicable for release_create, pre_release_create commands (string, default=main) - file : Specifies the asset file name. Must include full path. Applicable for release_create, pre_release_create commands (string, default=) If the -json option is not specified, the default json file $(ProgramFiles)\\Nbuild\\NTools.json is used . nbuild.targets See nbuild.targets for more information on how to create a nbuild.targets file. common.targets The common.targets file includes all the defaults targets needed to build, test and deploy a solution. The common.targets file is located in the $(ProgramFiles)\\Nbuild folder. The nbuild.targets file in the solution folder imports the common.targets file Below is list of common targets that are defined in the common.targets file Target Name Description PROPERTIES Common properties that will be used by all targets CLEAN Clean up the project and artifacts folder INSTALL_DEP Install dependencies TELEMETRY_OPT_OUT Opt out of the DOTNET_CLI_TELEMETRY_OPTOUT - move to common STAGE Create a stage package for testing PROD Create a production package for release STAGE_DEPLOY Create a stage package and deploy for testing PROD_DEPLOY Create a production package and deploy for release SOLUTION Build the solution Release configuration using dotnet build SOLUTION_MSBUILD Build the solution Release configuration using MSBuild PACKAGE Create a package for the solution default is a zip file of all artifacts COPY_ARTIFACTS Save the artifacts to the artifacts folder DEPLOY Deploy the package. default is to extract artifacts into DeploymentProperty folder TEST Run all tests using dotnet test in Release mode TEST_DEBUG Run all tests using dotnet test in Debug mode IS_ADMIN Check if current process is running in admin mode AdminCheckExitCode property is set SingleProject Example how to build a single project HandleError Error handling placeholder Examples This section provides examples of how to use the nb.exe command line tool. The examples assume that you are running a powershell terminal. 1. List Installed Applications nb.exe list -json $env:ProgramFiles\\tools.json Lists all applications specified in the provided JSON file. 2. Install Applications nb.exe install -json $env:ProgramFiles\\tools.json Downloads and installs applications specified in the JSON file (requires admin privileges). This checks if the application is already installed and if not it will install it. If the application is already installed, it will skip the installation. 3. Display Git Information nb.exe git_info Displays the current Git branch and tag information for the local repository. 4. Run a Build Target nb.exe stage -v true Runs the stage target defined in the nbuild.targets file with verbose output enabled. 5. List nbuild targets nb.exe targets Lists all available build targets defined in the nbuild.targets file and saves them in the targets.md file. 6. Set a Specific Git Tag nb.exe git_settag -tag 1.0.0 Sets the specified Git tag ( 1.0.0 ) in the local repository. 7. Automatically Set the Next Git Tag nb.exe git_autotag -buildtype stage Automatically generates and sets the next Git tag based on the specified build type ( stage or prod ). 8. Push the Next Git Tag to Remote nb.exe git_push_autotag -buildtype prod Automatically generates the next Git tag based on the specified build type ( prod ) and pushes it to the remote repository. 9. Display the Current Git Branch nb.exe git_branch Displays the current Git branch in the local repository. 10. Clone a Git Repository nb.exe git_clone -url https://github.com/example/repo -path C:\\Projects Clones the specified Git repository ( https://github.com/example/repo ) into the specified path ( C:\\Projects ). 11. Delete a Specific Tag nb.exe git_deletetag -tag 1.0.0 -v true 12. Creating a Release To create a release for the repository my-repo with the tag 1.0.0 , branch main , and an asset located at C:\\Releases\\1.0.0.zip , you would use the following command: nb.exe release_create -repo userName/my-repo -tag 1.0.0 -branch main -file C:\\Releases\\1.1.0.zip 13. Creating a Pre-Release To create a pre-release for the repository my-repo with the tag 1.0.0 , branch main , and an asset located at C:\\Releases\\1.0.0.zip , you would use the following command: nb.exe pre_release_create -repo userName/my-repo -tag 1.0.0 -branch main -file C:\\Releases\\1.1.0.zip 14. Downloading an Asset To download an asset from the release with the tag 1.0.0 in the repository my-repo to the path C:\\Downloads : nb.exe release_download -repo userName/my-repo -tag 1.0.0 -path C:\\Downloads An asset named 1.0.0.zip will be downloaded to the specified path if it exists in the release. 15. Creating a Release with Full GitHub URL To create a release for the repository my-repo with the tag 1.0.0 , branch main , and an asset located at C:\\Releases\\1.0.0.zip , using the full GitHub URL: nb.exe release_create -repo https://github.com/userName/my-repo -tag 1.0.0 -branch main -file C:\\Releases\\1.0.0.zip 16. Downloading an Asset with Full GitHub URL To download an asset from the release with the tag 1.0.0 in the repository my-repo to the path C:\\Downloads , using the full GitHub URL: nb.exe release_download -repo https://github.com/userName/my-repo -tag 1.0.0 -path C:\\Downloads An asset named 1.0.0.zip will be downloaded to the specified path if it exists in the release. 16. Getting latest 3 releases and the newest pre-release (if newer than the latest release) nb.exe list_release -repo https://github.com/userName/my-repo","title":"Nbuild (nb.exe)"},{"location":"ntools/nbuild/#nbuild","text":"Nbuild ( nb.exe ) is a wrapper for MSBuild that simplifies building solutions and provides a way to define and run custom targets. Nb.exe is also a command line tool that installs the development tools and run times required to build and test any solution. To build a target type Nb.exe [Target Name] The list of targets is generated by running the Nb.exe targets command. Nb.exe expects the nbuild.targets file to be present in the solution folder. Below is a full list of options that can be used with Nb.exe :","title":"Nbuild"},{"location":"ntools/nbuild/#usage","text":"Nb.exe command [-json value] [-v value] [-url value] [-tag value] [-path value] [-buildtype value] [-repo value] [-branch value] [-file value] - command : Specifies the command to execute. list -> Lists apps specified in the -json option. install -> Downloads and installs apps specified in the -json option (requires admin privileges). uninstall -> Uninstalls apps specified in the -json option (requires admin privileges). download -> Downloads tools or apps listed in the -json option (requires admin privileges). targets -> Lists available build targets and saves them in the targets.md file. path -> Displays the environment PATH variable for the local machine. git_info -> Displays the current git information for the local repository. git_settag -> Sets the specified tag using the -tag option. git_autotag -> Sets the next tag based on the build type: STAGE or PROD. git_push_autotag -> Sets the next tag based on the build type and pushes to the remote repository. git_branch -> Displays the current git branch in the local repository. git_clone -> Clones the specified Git repository using the -url option. git_deletetag -> Deletes the specified tag using the -tag option. release_create -> Creates a GitHub release. Requires -repo, -tag, -branch, and -file options. pre_release_create -> Creates a GitHub pre-release. Requires -repo, -tag, -branch, and -file options. release_download -> Downloads a specific asset from a GitHub release. Requires -repo, -tag, and -path (optional, defaults to current directory). list_release -> Lists latest 3 releases for the specified repository (and latest pre-release if newer). Requires -repo. ---- The nbuild.exe can also execute targets defined in an nbuild.targets file if one exists in the current folder. To execute a target defined in nbuild.targets, simply use its name as the command. For example, if nbuild.targets defines a target named 'build', you can run it with: `nb.exe build` (one of list,install,uninstall,download,targets,path,git_info,git_settag,git_autotag,git_push_autotag,git_branch,git_clone,git_deletetag,release_create,pre_release_create,release_download,list_release, required) - json : Specifies the JSON file that holds the list of apps. Only valid for the install, download, and list commands. - By default, the -json option points to the ntools deployment folder: $(ProgramFiles)\\build\\ntools.json. Sample JSON file: https://github.com/naz-hage/ntools/blob/main/dev-setup/ntools.json (string, default=$(ProgramFiles)\\nbuild\\ntools.json) - v : Optional parameter which sets the console output verbose level ---- - if no command line options are specified with the -v option , i.e.: 'Nb.exe stage -v true` `Nb` will run an MSbuild target `stage` defined in a `nbuild.targets` file which present in the solution folder. Run `Nb.exe Targets` to list the available targets. -v Possible Values: (true or false, default=False) - url : Specifies the Git repository URL. (string, default=) - tag : Specifies the tag used for git_settag and git_deletetag commands. (string, default=) - path : Specifies the path used for git_clone, pre_release_create and release_create commands. If not specified, the current directory will be used. for pre_release_create and release_create commands, it must be an absolute path (string, default=) - buildtype : Specifies the build type used for git_autotag and git_push_autotag commands. Possible values: STAGE, PROD. (string, default=) - repo : Specifies the Git repository in the format any of the following formats: repoName (UserName is declared the `OWNER` environment variable) userName/repoName https://github.com/userName/repoName (Full URL to the repository on GitHub). This is applicable to release_create, pre_release_create and release_download commands. (string, default=) - branch : Specifies the branch name. Applicable for release_create, pre_release_create commands (string, default=main) - file : Specifies the asset file name. Must include full path. Applicable for release_create, pre_release_create commands (string, default=) If the -json option is not specified, the default json file $(ProgramFiles)\\Nbuild\\NTools.json is used .","title":"Usage"},{"location":"ntools/nbuild/#nbuildtargets","text":"See nbuild.targets for more information on how to create a nbuild.targets file.","title":"nbuild.targets"},{"location":"ntools/nbuild/#commontargets","text":"The common.targets file includes all the defaults targets needed to build, test and deploy a solution. The common.targets file is located in the $(ProgramFiles)\\Nbuild folder. The nbuild.targets file in the solution folder imports the common.targets file Below is list of common targets that are defined in the common.targets file Target Name Description PROPERTIES Common properties that will be used by all targets CLEAN Clean up the project and artifacts folder INSTALL_DEP Install dependencies TELEMETRY_OPT_OUT Opt out of the DOTNET_CLI_TELEMETRY_OPTOUT - move to common STAGE Create a stage package for testing PROD Create a production package for release STAGE_DEPLOY Create a stage package and deploy for testing PROD_DEPLOY Create a production package and deploy for release SOLUTION Build the solution Release configuration using dotnet build SOLUTION_MSBUILD Build the solution Release configuration using MSBuild PACKAGE Create a package for the solution default is a zip file of all artifacts COPY_ARTIFACTS Save the artifacts to the artifacts folder DEPLOY Deploy the package. default is to extract artifacts into DeploymentProperty folder TEST Run all tests using dotnet test in Release mode TEST_DEBUG Run all tests using dotnet test in Debug mode IS_ADMIN Check if current process is running in admin mode AdminCheckExitCode property is set SingleProject Example how to build a single project HandleError Error handling placeholder","title":"common.targets"},{"location":"ntools/nbuild/#examples","text":"This section provides examples of how to use the nb.exe command line tool. The examples assume that you are running a powershell terminal.","title":"Examples"},{"location":"ntools/nbuild/#1-list-installed-applications","text":"nb.exe list -json $env:ProgramFiles\\tools.json Lists all applications specified in the provided JSON file.","title":"1. List Installed Applications"},{"location":"ntools/nbuild/#2-install-applications","text":"nb.exe install -json $env:ProgramFiles\\tools.json Downloads and installs applications specified in the JSON file (requires admin privileges). This checks if the application is already installed and if not it will install it. If the application is already installed, it will skip the installation.","title":"2. Install Applications"},{"location":"ntools/nbuild/#3-display-git-information","text":"nb.exe git_info Displays the current Git branch and tag information for the local repository.","title":"3. Display Git Information"},{"location":"ntools/nbuild/#4-run-a-build-target","text":"nb.exe stage -v true Runs the stage target defined in the nbuild.targets file with verbose output enabled.","title":"4. Run a Build Target"},{"location":"ntools/nbuild/#5-list-nbuild-targets","text":"nb.exe targets Lists all available build targets defined in the nbuild.targets file and saves them in the targets.md file.","title":"5. List nbuild targets"},{"location":"ntools/nbuild/#6-set-a-specific-git-tag","text":"nb.exe git_settag -tag 1.0.0 Sets the specified Git tag ( 1.0.0 ) in the local repository.","title":"6. Set a Specific Git Tag"},{"location":"ntools/nbuild/#7-automatically-set-the-next-git-tag","text":"nb.exe git_autotag -buildtype stage Automatically generates and sets the next Git tag based on the specified build type ( stage or prod ).","title":"7. Automatically Set the Next Git Tag"},{"location":"ntools/nbuild/#8-push-the-next-git-tag-to-remote","text":"nb.exe git_push_autotag -buildtype prod Automatically generates the next Git tag based on the specified build type ( prod ) and pushes it to the remote repository.","title":"8. Push the Next Git Tag to Remote"},{"location":"ntools/nbuild/#9-display-the-current-git-branch","text":"nb.exe git_branch Displays the current Git branch in the local repository.","title":"9. Display the Current Git Branch"},{"location":"ntools/nbuild/#10-clone-a-git-repository","text":"nb.exe git_clone -url https://github.com/example/repo -path C:\\Projects Clones the specified Git repository ( https://github.com/example/repo ) into the specified path ( C:\\Projects ).","title":"10. Clone a Git Repository"},{"location":"ntools/nbuild/#11-delete-a-specific-tag","text":"nb.exe git_deletetag -tag 1.0.0 -v true","title":"11. Delete a Specific Tag"},{"location":"ntools/nbuild/#12-creating-a-release","text":"To create a release for the repository my-repo with the tag 1.0.0 , branch main , and an asset located at C:\\Releases\\1.0.0.zip , you would use the following command: nb.exe release_create -repo userName/my-repo -tag 1.0.0 -branch main -file C:\\Releases\\1.1.0.zip","title":"12. Creating a Release"},{"location":"ntools/nbuild/#13-creating-a-pre-release","text":"To create a pre-release for the repository my-repo with the tag 1.0.0 , branch main , and an asset located at C:\\Releases\\1.0.0.zip , you would use the following command: nb.exe pre_release_create -repo userName/my-repo -tag 1.0.0 -branch main -file C:\\Releases\\1.1.0.zip","title":"13. Creating a Pre-Release"},{"location":"ntools/nbuild/#14-downloading-an-asset","text":"To download an asset from the release with the tag 1.0.0 in the repository my-repo to the path C:\\Downloads : nb.exe release_download -repo userName/my-repo -tag 1.0.0 -path C:\\Downloads An asset named 1.0.0.zip will be downloaded to the specified path if it exists in the release.","title":"14. Downloading an Asset"},{"location":"ntools/nbuild/#15-creating-a-release-with-full-github-url","text":"To create a release for the repository my-repo with the tag 1.0.0 , branch main , and an asset located at C:\\Releases\\1.0.0.zip , using the full GitHub URL: nb.exe release_create -repo https://github.com/userName/my-repo -tag 1.0.0 -branch main -file C:\\Releases\\1.0.0.zip","title":"15. Creating a Release with Full GitHub URL"},{"location":"ntools/nbuild/#16-downloading-an-asset-with-full-github-url","text":"To download an asset from the release with the tag 1.0.0 in the repository my-repo to the path C:\\Downloads , using the full GitHub URL: nb.exe release_download -repo https://github.com/userName/my-repo -tag 1.0.0 -path C:\\Downloads An asset named 1.0.0.zip will be downloaded to the specified path if it exists in the release.","title":"16. Downloading an Asset with Full GitHub URL"},{"location":"ntools/nbuild/#16-getting-latest-3-releases-and-the-newest-pre-release-if-newer-than-the-latest-release","text":"nb.exe list_release -repo https://github.com/userName/my-repo","title":"16. Getting latest 3 releases and the newest pre-release (if newer than the latest release)"},{"location":"ntools/nbuildtasks/","text":"NbuildTasks NbuildTasks (nbuildtasks.dll) is a class library that exposes custom MSBuild tasks. It is used by Nbuild to perform various tasks such as web download and tools installation during the build of any project. List of Tasks Task Name Description RedError Displays an error message in red color in the console output. Git Git commands such as get or set the tag from the branch or build type and displays it in the console output. ColorMessage Displays a message in the console output with the specified color. FileVersion Gets the version of the specified file. WebDownload Downloads a file from the specified URL. Unzip Unzips the specified file. Zip Zips the specified file. Pwsh Runs a PowerShell Core script from MSBuild. UpdateVersionsInDocs Updates version numbers in documentation files. Here are examples of custom Tasks that can be used during builds: RedError <!-- This target uses the `RedError` task to display an error message in red color --> <Target Name=\"RED_ERROR\"> <RedError Message=\"This is an error message displayed in Red\" /> </Target> Git <Target Name=\"TAG\"> <-- This target uses the `GetTag` task to display the tag from a branch --> <GetTag Branch=\"$(Branch)\" BuildType=\"$(BuildType)\"> <Output TaskParameter=\"Tag\" PropertyName=\"Tag\" /> </GetTag> <Message Text=\"Tag: $(Tag)\" Importance=\"high\" /> </Target> ColorMessage <!-- This target uses the `ColorMessage` task to display a message with a specified color --> <Target Name=\"COLOR_MESSAGE\"> <ColorMessage Message=\"This is a message displayed in Yellow\" Color=\"Yellow\" /> </Target> FileVersion <!-- This target uses the `FileVersion` task to file version of specified file --> <Target Name=\"FILE_VERSION\"> <PropertyGroup> <FileExe>$(ProgramFiles)\\Nbuild\\nb.exe</FileExe> </PropertyGroup> <FileVersion Name=\"$(FileExe)\" Condition=\"Exists('$(FileExe)')\" > <Output TaskParameter=\"Output\" PropertyName=\"Version\" /> </FileVersion> </Target> WebDownload <!-- This target uses the `WebDownload` task to download a file from a specified URL --> <Target Name=\"WEB_DOWNLOAD\" DependsOnTargets=\"IS_ADMIN\" > <PropertyGroup> <!-- visit https://nodejs.org/dist/ to get the latest stable version --> <DownloadsDirectory>c:\\NtoolsDownloads</DownloadsDirectory> <NodeAppName>Node.js</NodeAppName> <NodeTargetVersion>21.5.0</NodeTargetVersion> <WebUri>https://nodejs.org/dist/v$(NodeTargetVersion)/node-v$(NodeTargetVersion)-x64.msi</WebUri> <FileName>$(DownloadsDirectory)\\node-v$(NodeTargetVersion)-x64.msi</FileName> </PropertyGroup> <RedError Condition=\"'$(IsAdmin)' == false\" Message=\"Must be an admin to install $(NodeAppName)\" /> <Delete Files=\"$(FileName)\" Condition=\"Exists('$(FileName)') == true\" /> <WebDownload WebUri=\"$(WebUri)\" FileName=\"$(FileName)\" /> <Message Text=\"==> NODE_DONE\"/> </Target> Unzip <!-- This target uses the `Unzip` task to decompress a specified file --> <Target Name=\"UNZIP\"> <PropertyGroup> <FileName>c:\\temp\\source.zip</FileName> <Path>c:\\temp\\test1</Path> </PropertyGroup> <Unzip FileName=\"$(FileName)\" Destination=\"$(Path)\" /> <Message Text=\"==> ZIP_DONE\"/> </Target> Zip <!-- This target uses the `Zip` task to compress a specified file --> <Target Name=\"ZIP\"> <PropertyGroup> <FileName>c:\\temp\\source.zip</FileName> <Path>c:\\temp\\test</Path> </PropertyGroup> <Zip FileName=\"$(FileName)\" Path=\"$(Path)\" /> <Message Text=\"==> ZIP_DONE\"/> </Target> UpdateVersionsInDocs <!-- This target uses the `UpdateVersionsInDocs` task to update version numbers in documentation files --> <Target Name=\"UPDATE_DOC_VERSIONS\"> <UpdateVersionsInDocs DocsPath=\"$(SolutionDir)docs\" Version=\"$(Version)\" /> </Target> Pwsh <!-- This target uses the `Pwsh` custom NTools MS Build task to launch a PowerShell Core script --> <Target Name=\"INSTALL_NTOOLS\"> <Pwsh ScriptPath=\"$(SolutionDir)\\dev-setup\\install.ps1\" Arguments=\"\" WorkingDirectory =\"$(SolutionDir)\\dev-setup\"/> <Message Text=\"==> INSTALL_NTOOLS_DONE\"/> </Target> You can also find the complete list of predefined MSBuild properties in the Microsoft documentation . Here are few examples: $(MSBuildProjectFile) : The file name of the project file. $(MSBuildProjectName) : The file name of the project file without the extension. $(MSBuildProjectExtension) : The extension of the project file. $(MSBuildProjectFullPath) : The absolute path of the project file. $(MSBuildThisFileDirectory) : The directory of the MSBuild file that is currently being processed.","title":"Nbuild Tasks"},{"location":"ntools/nbuildtasks/#nbuildtasks","text":"NbuildTasks (nbuildtasks.dll) is a class library that exposes custom MSBuild tasks. It is used by Nbuild to perform various tasks such as web download and tools installation during the build of any project.","title":"NbuildTasks"},{"location":"ntools/nbuildtasks/#list-of-tasks","text":"Task Name Description RedError Displays an error message in red color in the console output. Git Git commands such as get or set the tag from the branch or build type and displays it in the console output. ColorMessage Displays a message in the console output with the specified color. FileVersion Gets the version of the specified file. WebDownload Downloads a file from the specified URL. Unzip Unzips the specified file. Zip Zips the specified file. Pwsh Runs a PowerShell Core script from MSBuild. UpdateVersionsInDocs Updates version numbers in documentation files. Here are examples of custom Tasks that can be used during builds:","title":"List of Tasks"},{"location":"ntools/nbuildtasks/#rederror","text":"<!-- This target uses the `RedError` task to display an error message in red color --> <Target Name=\"RED_ERROR\"> <RedError Message=\"This is an error message displayed in Red\" /> </Target>","title":"RedError"},{"location":"ntools/nbuildtasks/#git","text":"<Target Name=\"TAG\"> <-- This target uses the `GetTag` task to display the tag from a branch --> <GetTag Branch=\"$(Branch)\" BuildType=\"$(BuildType)\"> <Output TaskParameter=\"Tag\" PropertyName=\"Tag\" /> </GetTag> <Message Text=\"Tag: $(Tag)\" Importance=\"high\" /> </Target>","title":"Git"},{"location":"ntools/nbuildtasks/#colormessage","text":"<!-- This target uses the `ColorMessage` task to display a message with a specified color --> <Target Name=\"COLOR_MESSAGE\"> <ColorMessage Message=\"This is a message displayed in Yellow\" Color=\"Yellow\" /> </Target>","title":"ColorMessage"},{"location":"ntools/nbuildtasks/#fileversion","text":"<!-- This target uses the `FileVersion` task to file version of specified file --> <Target Name=\"FILE_VERSION\"> <PropertyGroup> <FileExe>$(ProgramFiles)\\Nbuild\\nb.exe</FileExe> </PropertyGroup> <FileVersion Name=\"$(FileExe)\" Condition=\"Exists('$(FileExe)')\" > <Output TaskParameter=\"Output\" PropertyName=\"Version\" /> </FileVersion> </Target>","title":"FileVersion"},{"location":"ntools/nbuildtasks/#webdownload","text":"<!-- This target uses the `WebDownload` task to download a file from a specified URL --> <Target Name=\"WEB_DOWNLOAD\" DependsOnTargets=\"IS_ADMIN\" > <PropertyGroup> <!-- visit https://nodejs.org/dist/ to get the latest stable version --> <DownloadsDirectory>c:\\NtoolsDownloads</DownloadsDirectory> <NodeAppName>Node.js</NodeAppName> <NodeTargetVersion>21.5.0</NodeTargetVersion> <WebUri>https://nodejs.org/dist/v$(NodeTargetVersion)/node-v$(NodeTargetVersion)-x64.msi</WebUri> <FileName>$(DownloadsDirectory)\\node-v$(NodeTargetVersion)-x64.msi</FileName> </PropertyGroup> <RedError Condition=\"'$(IsAdmin)' == false\" Message=\"Must be an admin to install $(NodeAppName)\" /> <Delete Files=\"$(FileName)\" Condition=\"Exists('$(FileName)') == true\" /> <WebDownload WebUri=\"$(WebUri)\" FileName=\"$(FileName)\" /> <Message Text=\"==> NODE_DONE\"/> </Target>","title":"WebDownload"},{"location":"ntools/nbuildtasks/#unzip","text":"<!-- This target uses the `Unzip` task to decompress a specified file --> <Target Name=\"UNZIP\"> <PropertyGroup> <FileName>c:\\temp\\source.zip</FileName> <Path>c:\\temp\\test1</Path> </PropertyGroup> <Unzip FileName=\"$(FileName)\" Destination=\"$(Path)\" /> <Message Text=\"==> ZIP_DONE\"/> </Target>","title":"Unzip"},{"location":"ntools/nbuildtasks/#zip","text":"<!-- This target uses the `Zip` task to compress a specified file --> <Target Name=\"ZIP\"> <PropertyGroup> <FileName>c:\\temp\\source.zip</FileName> <Path>c:\\temp\\test</Path> </PropertyGroup> <Zip FileName=\"$(FileName)\" Path=\"$(Path)\" /> <Message Text=\"==> ZIP_DONE\"/> </Target>","title":"Zip"},{"location":"ntools/nbuildtasks/#updateversionsindocs","text":"<!-- This target uses the `UpdateVersionsInDocs` task to update version numbers in documentation files --> <Target Name=\"UPDATE_DOC_VERSIONS\"> <UpdateVersionsInDocs DocsPath=\"$(SolutionDir)docs\" Version=\"$(Version)\" /> </Target>","title":"UpdateVersionsInDocs"},{"location":"ntools/nbuildtasks/#pwsh","text":"<!-- This target uses the `Pwsh` custom NTools MS Build task to launch a PowerShell Core script --> <Target Name=\"INSTALL_NTOOLS\"> <Pwsh ScriptPath=\"$(SolutionDir)\\dev-setup\\install.ps1\" Arguments=\"\" WorkingDirectory =\"$(SolutionDir)\\dev-setup\"/> <Message Text=\"==> INSTALL_NTOOLS_DONE\"/> </Target> You can also find the complete list of predefined MSBuild properties in the Microsoft documentation . Here are few examples: $(MSBuildProjectFile) : The file name of the project file. $(MSBuildProjectName) : The file name of the project file without the extension. $(MSBuildProjectExtension) : The extension of the project file. $(MSBuildProjectFullPath) : The absolute path of the project file. $(MSBuildThisFileDirectory) : The directory of the MSBuild file that is currently being processed.","title":"Pwsh"},{"location":"ntools/ntools/","text":"The Windows dev environment has good information on how to setup a Windows dev environment. The table below list the latest dev tools used in Ntools. Tool Version Last Checked on Argo CD 2.14.11 04-May-25 Azure CLI 2.70.0 01-Jul-25 Burp Suite 2021.11.2 01-Oct-23 Dotnet Runtime 9.0.2 10-Mar-25 Dotnet8 SDK 8.0.408 02-May-25 Dotnet9 Runtime 9.0.203 02-May-25 Draw.io N/A 01-Oct-23 Git for Windows 2.50.0 01-Jul-25 Install Docker Desktop on Windows 4.38.0.0 03-Mar-25 kubernetes 1.33.0 01-Jul-25 minikube 1.35.0 01-Jul-25 MongoDB Community Server 8.0.5 01-Jul-25 Node.js 22.12.0 01-Jul-25 Ntools 1.22.0 01-Jul-25 NuGet 6.12.1 01-Jul-25 pnpm 9.1.2 01-Jul-25 Postman Get Started for Free v11.36.0 10-Mar-25 PowerShell 7.5.2 01-Jul-25 Python 3.13.3 01-Jul-25 SysInternals 2.90.0 22-Jun-24 Terraform 1.11.1 01-Jul-25 Terraform Lint 0.55.1 01-Jul-25 Visual Studio 2022 Community Edition 17.11.3 14-Sep-24 Visual Studio Code 1.100.1 01-Jul-25 Windows Terminal 1.21.10351.0 10-Mar-25","title":"Development Tools"},{"location":"ntools/wi/","text":"wi: Azure DevOps Work Item CLI Utility wi is a command-line tool for creating Product Backlog Items (PBIs) and child tasks in Azure DevOps from a services file. It is built using System.CommandLine and is part of the ntools suite. Features Create PBIs for multiple services from a text file Create child tasks automatically with the same title as the PBI Azure DevOps integration via REST API Batch processing for multiple services Environment-based configuration for organization and project settings Prerequisites Environment Variables The following environment variables must be set: PAT (Required): Personal Access Token for Azure DevOps authentication AZURE_DEVOPS_ORGANIZATION (Optional): Azure DevOps organization URL Default: https://dev.azure.com/nazh AZURE_DEVOPS_PROJECT (Optional): Azure DevOps project name Default: Proto Personal Access Token Setup Go to Azure DevOps \u2192 User Settings \u2192 Personal Access Tokens Create a new token with Work Items (Read & Write) permissions Set the PAT environment variable: powershell $env:PAT = \"your-personal-access-token\" Usage Create PBIs for Multiple Services Creates PBIs for each service listed in a file, with automatic child task creation: wi --services services.txt --parentId 12345 Options: - -s , --services (Required): Path to services.txt file containing service names (one per line) - -p , --parentId (Required): Parent work item ID to link the PBIs to Create Child Task for Specific PBI Creates a child task for an existing PBI: wi --services services.txt --parentId 12345 --childTaskOfPbiId 67890 Additional Option: - -c , --childTaskOfPbiId : PBI ID to create a child task for (skips PBI creation) Services File Format The services file should contain one service name per line: Example services.txt : ServiceA ServiceB ServiceC UserManagementService PaymentProcessingService Work Item Creation Details PBI Creation Title Format : {ServiceName}: update pipeline to perform SCA Type : Product Backlog Item Parent : Links to the specified parent work item ID Child Task Creation Title : Same as the parent PBI Type : Task Parent : Links to the created PBI Examples Basic Usage # Set required environment variables $env:PAT = \"your-pat-token\" $env:AZURE_DEVOPS_ORGANIZATION = \"https://dev.azure.com/yourorg\" $env:AZURE_DEVOPS_PROJECT = \"YourProject\" # Create PBIs for all services in the file wi --services my-services.txt --parentId 54321 Create Child Task Only # Create a child task for an existing PBI wi --services services.txt --parentId 54321 --childTaskOfPbiId 98765 Output The tool provides console output showing: - Organization and project being used - Success/failure status for each PBI creation - Created work item IDs Example Output: Organization: https://dev.azure.com/yourorg Project: YourProject Created PBI for ServiceA: ID 12346 Created child task for PBI 12346 Created PBI for ServiceB: ID 12347 Created child task for PBI 12347 Error Handling Common issues and solutions: \"PAT environment variable is not set\" : Set the PAT environment variable with a valid Azure DevOps Personal Access Token \"Failed to read services file\" : Ensure the services file path is correct and accessible \"Failed to create PBI\" : Check PAT permissions and Azure DevOps connectivity Authentication errors : Verify PAT is valid and has Work Items read/write permissions Integration with ntools The wi tool integrates seamlessly with other ntools utilities and can be used in automation scripts and CI/CD pipelines for Azure DevOps work item management.","title":"wi (wi.exe)"},{"location":"ntools/wi/#wi-azure-devops-work-item-cli-utility","text":"wi is a command-line tool for creating Product Backlog Items (PBIs) and child tasks in Azure DevOps from a services file. It is built using System.CommandLine and is part of the ntools suite.","title":"wi: Azure DevOps Work Item CLI Utility"},{"location":"ntools/wi/#features","text":"Create PBIs for multiple services from a text file Create child tasks automatically with the same title as the PBI Azure DevOps integration via REST API Batch processing for multiple services Environment-based configuration for organization and project settings","title":"Features"},{"location":"ntools/wi/#prerequisites","text":"","title":"Prerequisites"},{"location":"ntools/wi/#environment-variables","text":"The following environment variables must be set: PAT (Required): Personal Access Token for Azure DevOps authentication AZURE_DEVOPS_ORGANIZATION (Optional): Azure DevOps organization URL Default: https://dev.azure.com/nazh AZURE_DEVOPS_PROJECT (Optional): Azure DevOps project name Default: Proto","title":"Environment Variables"},{"location":"ntools/wi/#personal-access-token-setup","text":"Go to Azure DevOps \u2192 User Settings \u2192 Personal Access Tokens Create a new token with Work Items (Read & Write) permissions Set the PAT environment variable: powershell $env:PAT = \"your-personal-access-token\"","title":"Personal Access Token Setup"},{"location":"ntools/wi/#usage","text":"","title":"Usage"},{"location":"ntools/wi/#create-pbis-for-multiple-services","text":"Creates PBIs for each service listed in a file, with automatic child task creation: wi --services services.txt --parentId 12345 Options: - -s , --services (Required): Path to services.txt file containing service names (one per line) - -p , --parentId (Required): Parent work item ID to link the PBIs to","title":"Create PBIs for Multiple Services"},{"location":"ntools/wi/#create-child-task-for-specific-pbi","text":"Creates a child task for an existing PBI: wi --services services.txt --parentId 12345 --childTaskOfPbiId 67890 Additional Option: - -c , --childTaskOfPbiId : PBI ID to create a child task for (skips PBI creation)","title":"Create Child Task for Specific PBI"},{"location":"ntools/wi/#services-file-format","text":"The services file should contain one service name per line: Example services.txt : ServiceA ServiceB ServiceC UserManagementService PaymentProcessingService","title":"Services File Format"},{"location":"ntools/wi/#work-item-creation-details","text":"","title":"Work Item Creation Details"},{"location":"ntools/wi/#pbi-creation","text":"Title Format : {ServiceName}: update pipeline to perform SCA Type : Product Backlog Item Parent : Links to the specified parent work item ID","title":"PBI Creation"},{"location":"ntools/wi/#child-task-creation","text":"Title : Same as the parent PBI Type : Task Parent : Links to the created PBI","title":"Child Task Creation"},{"location":"ntools/wi/#examples","text":"","title":"Examples"},{"location":"ntools/wi/#basic-usage","text":"# Set required environment variables $env:PAT = \"your-pat-token\" $env:AZURE_DEVOPS_ORGANIZATION = \"https://dev.azure.com/yourorg\" $env:AZURE_DEVOPS_PROJECT = \"YourProject\" # Create PBIs for all services in the file wi --services my-services.txt --parentId 54321","title":"Basic Usage"},{"location":"ntools/wi/#create-child-task-only","text":"# Create a child task for an existing PBI wi --services services.txt --parentId 54321 --childTaskOfPbiId 98765","title":"Create Child Task Only"},{"location":"ntools/wi/#output","text":"The tool provides console output showing: - Organization and project being used - Success/failure status for each PBI creation - Created work item IDs Example Output: Organization: https://dev.azure.com/yourorg Project: YourProject Created PBI for ServiceA: ID 12346 Created child task for PBI 12346 Created PBI for ServiceB: ID 12347 Created child task for PBI 12347","title":"Output"},{"location":"ntools/wi/#error-handling","text":"Common issues and solutions: \"PAT environment variable is not set\" : Set the PAT environment variable with a valid Azure DevOps Personal Access Token \"Failed to read services file\" : Ensure the services file path is correct and accessible \"Failed to create PBI\" : Check PAT permissions and Azure DevOps connectivity Authentication errors : Verify PAT is valid and has Work Items read/write permissions","title":"Error Handling"},{"location":"ntools/wi/#integration-with-ntools","text":"The wi tool integrates seamlessly with other ntools utilities and can be used in automation scripts and CI/CD pipelines for Azure DevOps work item management.","title":"Integration with ntools"}]}
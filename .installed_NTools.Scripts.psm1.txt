# NTools.Scripts module loader
# This file exposes a small public API and reuses the existing scripts/modules/*.psm1 helpers when available.

<#
Determine and cache the module base path at load time. This avoids calling Find-API at function
execution time which can return null in some contexts.
#>
$Script:NTools_ModuleBase = $null
if ($PSScriptRoot) { $Script:NTools_ModuleBase = $PSScriptRoot }
elseif ($MyInvocation -and $MyInvocation.MyCommand -and $MyInvocation.MyCommand.Path) { $Script:NTools_ModuleBase = Split-Path -Parent $MyInvocation.MyCommand.Path }
else {
    $mod = Get-Module -ListAvailable -Name 'NTools.Scripts' | Select-Object -First 1
    if ($mod -and $mod.ModuleBase) { $Script:NTools_ModuleBase = $mod.ModuleBase }
}

function Get-ModuleRoot {
    if ($Script:NTools_ModuleBase) { return $Script:NTools_ModuleBase }
    # last resort attempt
    $mod = Get-Module -ListAvailable -Name 'NTools.Scripts' | Select-Object -First 1
    if ($mod -and $mod.ModuleBase) { return $mod.ModuleBase }
    return $null
}

function Import-RepoModules {
    param([string]$moduleRoot)
    if (-not $moduleRoot) { return }
    try {
        $repoRootInfo = Resolve-Path -Path (Join-Path $moduleRoot '..\..') -ErrorAction SilentlyContinue
        if ($repoRootInfo) {
            $repoRoot = $repoRootInfo.ProviderPath
            $repoModules = Join-Path $repoRoot 'modules'
            if (Test-Path $repoModules) {
                Get-ChildItem -Path $repoModules -Filter '*.psm1' -File -ErrorAction SilentlyContinue | ForEach-Object {
                    try { . $_.FullName } catch { Write-Verbose "Failed to dot-source $($_.FullName): $_" }
                }
            }
        }
    } catch {
        Write-Verbose "Import-RepoModules error: $_"
    }
}

Import-RepoModules -moduleRoot (Get-ModuleRoot)

function Publish-AllProjects {
    param(
        [Parameter(Mandatory=$true)] [string]$OutputDir,
        [Parameter(Mandatory=$true)] [string]$Version
    )

    # If helper Invoke-ProjectPublish is available from Build.psm1, use it
    if (Get-Command -Name Invoke-ProjectPublish -ErrorAction SilentlyContinue) {
        $repoRoot = Resolve-Path (Join-Path (Get-ModuleRoot) '..\..')
        $projects = Get-ProjectFiles -SearchPath $repoRoot -ExcludeTests
        $success = 0; $failures = 0
        foreach ($p in $projects) {
            $res = Invoke-ProjectPublish -ProjectPath $p.FullName -OutputPath $OutputDir -ProductVersion $Version
            if ($res) { $success++ } else { $failures++ }
        }
        if ($failures -gt 0) { throw "$failures projects failed to publish" }
        return @{ Success = $success; Failures = $failures }
    }

    # Fallback: simple dotnet publish loop
    $projects = Get-ChildItem -Path (Resolve-Path (Join-Path (Get-ModuleRoot) '..\..')) -Recurse -Filter '*.csproj' -File | Where-Object { $_.Name -notmatch '(Test|Tests)' -and $_.FullName -notmatch '\\obj\\' }
    $failures = 0; $success = 0
    foreach ($p in $projects) {
        $projName = [System.IO.Path]::GetFileNameWithoutExtension($p.Name)
        $out = Join-Path $OutputDir $projName
        dotnet publish $p.FullName --configuration Release --output $out /p:Version=$Version
        if ($LASTEXITCODE -ne 0) { $failures++ } else { $success++ }
    }
    if ($failures -gt 0) { throw "$failures projects failed to publish" }
    return @{ Success = $success; Failures = $failures }
}

Export-ModuleMember -Function Publish-AllProjects

# Return the module package version. Attempts to read the module manifest first, then falls back
# to querying the module if installed to PSModulePath.
function Get-Version {
    try {
        $moduleRoot = Get-ModuleRoot
        $manifestPath = $null
        if ($moduleRoot) { $manifestPath = Join-Path $moduleRoot 'NTools.Scripts.psd1' }
        if (-not $manifestPath) {
            $modLookup = Get-Module -ListAvailable -Name 'NTools.Scripts' | Select-Object -First 1
            if ($modLookup -and $modLookup.ModuleBase) { $manifestPath = Join-Path $modLookup.ModuleBase 'NTools.Scripts.psd1' }
        }

        if ($manifestPath -and (Test-Path $manifestPath)) {
            try {
                if (Get-Command -Name Import-PowerShellDataFile -ErrorAction SilentlyContinue) {
                    $manifest = Import-PowerShellDataFile -Path $manifestPath
                } else {
                    $manifest = Invoke-Expression (Get-Content -Path $manifestPath -Raw)
                }
                if ($manifest -and $manifest.ContainsKey('ModuleVersion')) { return $manifest['ModuleVersion'] }
            } catch {
                Write-Verbose "Failed to read manifest at $manifestPath: ${_}"
            }
        }

        $mod = Get-Module -ListAvailable -Name 'NTools.Scripts' | Select-Object -First 1
        if ($mod -and $mod.Version) { return $mod.Version.ToString() }

        throw 'NTools.Scripts module not found'
    } catch {
        throw $_
    }
}

Export-ModuleMember -Function Get-Version

<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

	<!-- Reference: https://learn.microsoft.com/en-us/visualstudio/msbuild/walkthrough-using-msbuild?view=vs-2022 -->
	
	<Import Project="$(ProgramFiles)\Nbuild\common.targets"/>

	<PropertyGroup>
		<!-- This is the folder where the *.sln resides-->
		<DeploymentFolder>$(ProgramFiles)\Nbuild</DeploymentFolder>
		<!--  Modify these paths to match your Python installation -->
		<!-- Always use python.exe from PATH for portability -->
		<PipPath>python.exe -m pip</PipPath>
		<MkDocsExe>$(USERPROFILE)\AppData\Roaming\Python\Python313\Scripts\mkdocs.exe</MkDocsExe>
	</PropertyGroup>

	<!--Setup the ARTIFACTS folders for binaries and test results - override -->
	<Target Name="ARTIFACTS" DependsOnTargets="TAG">
	  <PropertyGroup>
		 <ArtifactsSolutionFolder>$(ArtifactsDir)\$(SolutionName)</ArtifactsSolutionFolder>
		 <SetupFolder>$(ArtifactsSolutionFolder)\release</SetupFolder>
		<ArtifactsFolder>$(ArtifactsSolutionFolder)\$(TargetRelease)\$(ProductVersion)</ArtifactsFolder>
		<ArtifactsTestResultsFolder>$(ArtifactsSolutionFolder)\TestResults\$(ProductVersion)</ArtifactsTestResultsFolder>
		<NbExe>$(OutputPathRelease)\nb.exe</NbExe>

          <!-- Default paths for local builds -->
		<CoverageFolder>$(ArtifactsSolutionFolder)\CoverageReport\$(ProductVersion)</CoverageFolder>
		
		<!-- Override paths for GitHub Actions -->
		<ArtifactsTestResultsFolder Condition="'$(GITHUB_ACTIONS)' == 'true'">$(SolutionDir)\TestResults\$(ProductVersion)</ArtifactsTestResultsFolder>
		<CoverageFolder Condition="'$(GITHUB_ACTIONS)' == 'true'">$(SolutionDir)\CoverageReport\$(ProductVersion)</CoverageFolder>

	  </PropertyGroup>  
	  <ItemGroup>
			<BinaryFiles 
					Include="
					$(SolutionDir)\$(TargetRelease)\*.json;
					$(SolutionDir)\Nbuild\resources\*.targets;
					$(SolutionDir)\scripts\build\*.ps1;
					$(SolutionDir)\scripts\module-package\*.ps1;
					$(SolutionDir)\scripts\module-package\*.psd1;
					$(SolutionDir)\scripts\module-package\*.psm1;
					$(SolutionDir)\Nbuild\resources\*.json"
					/>

			<RunTimesNetStandard20 Include = "
							   $(SolutionDir)\$(TargetRelease)\netstandard2.0\*.*"
								Exclude="
								$(SolutionDir)\$(TargetRelease)\**\*.pdb"
								/>

		</ItemGroup>
		
		<Message Text="==> DONE"/>
	</Target>

		
	<!-- Test for FileVersion task and powershell file-version.ps1-->
	<Target Name="FILE_VERSIONS"  DependsOnTargets="ARTIFACTS">
		<PropertyGroup>
			<FileName>$(SolutionDir)\$(TargetRelease)\nb.exe</FileName>
		</PropertyGroup>
		<Exec Command='powershell -File "$(SolutionDir)\dev-setup\list-file-version.ps1" "$(FileName)"' ConsoleToMSBuild="true">
			<Output TaskParameter="ConsoleOutput" PropertyName="Version" />
		</Exec>
		<Message Text="Powershell File version: $(Version)" />

		<FileVersion Name="%(BinaryFiles.Identity)" Condition="'%(Extension)'=='.exe' Or '%(Extension)'=='.dll'" >
			<Output TaskParameter="Output" PropertyName="Version"/>
		</FileVersion>
		<Message Text="File version: $(Version)" />
		
		<Message Text="==> DONE"/>

	</Target>
	
	<!-- Download Nbuild specified in the NbuildTargetVersion -->
	<Target Name="NBUILD_DOWNLOAD" DependsOnTargets="IS_ADMIN">
		<PropertyGroup>
		<WebUri>https://github.com/naz-hage/ntools/releases/download/$(NbuildTargetVersion)/$(NbuildTargetVersion).zip</WebUri>
		<FileName>$(DownloadsDirectory)\NBuildTools.zip</FileName>
		</PropertyGroup>

		<RedError Condition="'$(IsAdmin)' == false" Message="Must be an admin to install $(NbuildAppName)" />
		
		<Delete Files="$(FileName)" Condition="Exists('$(FileName)') == true" />
		
		<WebDownload WebUri="$(WebUri)" FileName="$(FileName)" />
		
		<Message Text="==> NBUILD_DONE"/>
	</Target>

	<!-- Setup development environment by importing ntools-scripts and calling Set-DevelopmentEnvironment -->
	<Target Name="SETUP_ENVIRONMENT" DependsOnTargets="IS_ADMIN">
		<Message Text="Setting up development environment (Set-DevelopmentEnvironment)" Importance="high" />
		<Exec Command='pwsh -NoProfile -NonInteractive -ExecutionPolicy Bypass -Command "Import-Module \"$(SolutionDir)\scripts\module-package\ntools-scripts.psm1\" -Force; Set-DevelopmentEnvironment -DevDrive \"$(DevDrive)\" -MainDir \"$(MainDir)\""' WorkingDirectory="$(SolutionDir)" />
		<Message Text="SETUP_ENVIRONMENT completed" Importance="high" />
	</Target>

	<!-- Test that ntools-scripts module is installed and can report a version -->
	<Target Name="TEST_NTOOLS_SCRIPTS" DependsOnTargets="PROPERTIES">
		<Message Text="Testing ntools-scripts installation" Importance="high" />
		<Exec Command='pwsh -NoProfile -NonInteractive -ExecutionPolicy Bypass -File "$(SolutionDir)\scripts\module-package\test-module.ps1" -BuildTools "$(BuildTools)"' WorkingDirectory="$(SolutionDir)" />
		<Message Text="ntools-scripts test completed" Importance="high" />
	</Target>

	<!-- Build docs locally for testing -->
	<Target Name="MKDOCS" >
		<!-- Check if Python is installed -->
		<Error Condition="!Exists('$(PythonPath)\python.exe')" Text="Python is not installed at $(PythonPath)" />

		<!-- Upgrade pip -->
		<Exec Command="&quot;$(PipPath)&quot; install --upgrade pip" WorkingDirectory="$(SolutionDir)">
			<Output TaskParameter="ExitCode" PropertyName="PipUpgradeExitCode" />
		</Exec>
		<Error Condition="'$(PipUpgradeExitCode)' != '0'" Text="Failed to upgrade pip. Exit code: $(PipUpgradeExitCode)" />

		<!-- Install mkdocs -->
		<Exec Command="&quot;$(PipPath)&quot; install mkdocs" WorkingDirectory="$(SolutionDir)">
			<Output TaskParameter="ExitCode" PropertyName="MkDocsInstallExitCode" />
		</Exec>
		<Error Condition="'$(MkDocsInstallExitCode)' != '0'" Text="Failed to install mkdocs. Exit code: $(MkDocsInstallExitCode)" />

		<!-- Build the documentation -->
		<Exec Command='"$(MkDocsExe)" build -d $(ArtifactsDir)\$(SolutionName)\docs' WorkingDirectory="$(SolutionDir)" />
		<Message Text="==> DONE" />
	</Target>

  <!-- Run nbTests and generate code coverage report -->
  <Target Name="RUN_NBTESTS_COVERAGE" DependsOnTargets="INSTALL_REPORTGENERATOR">
	<Exec Command="dotnet test &quot;$(SolutionDir)\nbTests\nbTests.csproj&quot; --collect:\&quot;XPlat Code Coverage\&quot;" WorkingDirectory="$(SolutionDir)" />
	<Exec Command="&quot;$(ReportGeneratorExe)&quot; -reports:$(SolutionDir)\TestResults\**\coverage.cobertura.xml -targetdir:$(SolutionDir)\TestResults\CoverageReport" />
	<Message Text="nbTests executed and code coverage report generated in TestResults\CoverageReport." />
	<Message Text="==> DONE" />
  </Target>


	<!-- mkdocs deploy locally -->
	<Target Name="MKDOCS_DEPLOY" AfterTargets="MKDOCS">
		<Exec Command='"$(MkDocsExe)" serve' WorkingDirectory="$(SolutionDir)"/>
		<Message Text="==> DONE" />
	</Target>

	<!-- Install python test dependencies for atools and run pytest (verbose) -->
	<Target Name="INSTALL_PYTHON_TEST_DEPS">
		<Message Text="Installing Python test dependencies for atools" Importance="high" />
		<PropertyGroup>
			<PythonExe>$(PythonPath)\python.exe</PythonExe>
			<PipExe Condition="'$(PipPath)' != ''">$(PipPath)</PipExe>
			<!-- Fallback to python -m pip if PipPath not set -->
			<PipExe Condition="'$(PipExe)' == ''">&quot;$(PythonExe)&quot; -m pip</PipExe>
			<AtoolsReq>$(SolutionDir)\atools\requirements.txt</AtoolsReq>
		</PropertyGroup>
		<!-- Use requirements.txt if it exists, else install pytest and pytest-mock -->
		<Exec Command='&quot;$(PipExe)&quot; install -r &quot;$(AtoolsReq)&quot;' WorkingDirectory="$(SolutionDir)" ContinueOnError="true">
			<Output TaskParameter="ExitCode" PropertyName="PipExitCode" />
		</Exec>
		<Message Text="pip install -r returned exit code $(PipExitCode)" Importance="high" />
		<!-- If requirements install failed or no requirements file, install minimal test deps -->
		<Exec Command='&quot;$(PipExe)&quot; install pytest pytest-mock' WorkingDirectory="$(SolutionDir)" Condition="!Exists('$(AtoolsReq)') Or '$(PipExitCode)' != '0'">
			<Output TaskParameter="ExitCode" PropertyName="PipFallbackExitCode" />
		</Exec>
		<Error Condition="'$(PipExitCode)' != '0' And '$(PipFallbackExitCode)' != '0'" Text="Failed to install python test dependencies. pip exit codes: $(PipExitCode), $(PipFallbackExitCode)" />
		<Message Text="==> DONE" />
	</Target>

	<!-- Run Python pytest for atools package (verbose) -->
	<Target Name="RUN_PYTESTS_VERBOSE" DependsOnTargets="INSTALL_PYTHON_TEST_DEPS" >
		<Message Text="Running Python pytest for atools (verbose)" Importance="high" />
		<PropertyGroup>
			<PythonExe>$(PythonPath)\python.exe</PythonExe>
			<!-- Allow overriding test path via TEST_PATH -->
			<TestPath Condition="'$(TestPath)' == ''">$(SolutionDir)\atools\tests</TestPath>
		</PropertyGroup>
		<!-- Run pytest with very verbose output (-vv) -->
		<Exec Command='&quot;$(PythonExe)&quot; -m pytest -vv &quot;$(TestPath)&quot;' WorkingDirectory="$(SolutionDir)" ConsoleToMSBuild="true">
			<Output TaskParameter="ExitCode" PropertyName="PytestExitCode" />
		</Exec>
		<Error Condition="'$(PytestExitCode)' != '0'" Text="Python pytest failed with exit code $(PytestExitCode). See output above." />
		<Message Text="==> DONE" />
	</Target>

	<!-- Run SDO tests specifically -->
	<Target Name="RUN_SDO_TESTS" DependsOnTargets="INSTALL_PYTHON_TEST_DEPS">
		<Message Text="Running SDO tests" Importance="high" />
		<PropertyGroup>
			<PythonExe>$(PythonPath)\python.exe</PythonExe>
			<!-- Allow overriding test path via TEST_PATH -->
			<SdoTestPath Condition="'$(SdoTestPath)' == ''">$(SolutionDir)\atools\tests</SdoTestPath>
		</PropertyGroup>
		<!-- Run pytest with very verbose output (-vv) on SDO tests -->
		<Exec Command='&quot;$(PythonExe)&quot; -m pytest -vv &quot;$(SdoTestPath)&quot;' WorkingDirectory="$(SolutionDir)" ConsoleToMSBuild="true">
			<Output TaskParameter="ExitCode" PropertyName="SdoPytestExitCode" />
		</Exec>
		<Error Condition="'$(SdoPytestExitCode)' != '0'" Text="SDO tests failed with exit code $(SdoPytestExitCode). See output above." />
		<Message Text="==> DONE" />
	</Target>

	<!-- Example to get the installation 
		Product code used for uninstallation of product -->
	<Target Name="GET_PRODUCT_CODES" >
		<Exec Command="wmic product where &quot;name like 'MongoDB%'&quot; get IdentifyingNumber, Name" ConsoleToMSBuild="true">
			<Output TaskParameter="ConsoleOutput" PropertyName="ProductsList" />
		</Exec>
		<ItemGroup>
			<Products Include="$(ProductsList.Split('&#xD;&#xA;', StringSplitOptions.RemoveEmptyEntries))" />
		</ItemGroup>
		<Message Text="@(Products)" Importance="high" />
	</Target>

	<!-- Display core properties-->
	<Target Name="CORE" DependsOnTargets="ARTIFACTS" >
		<Message Text="DevDrive: $(DevDrive)"/>
		<Message Text="MainDir: $(MainDir)"/>
		<Message Text="Product Version: $(ProductVersion)"/>
		<Message Text="SolutionName: $(SolutionName)"/>
		<Message Text="SolutionDir: $(SolutionDir)"/>
		<Message Text="DeploymentFolder: $(DeploymentFolder)"/>
		<Message Text="ArtifactsSolutionFolder: $(ArtifactsSolutionFolder)"/>
		<Message Text="SetupFolder: $(SetupFolder)"/>
		<Message Text="ArtifactsFolder: $(ArtifactsFolder)"/>
		<Message Text="ArtifactsTestResultsFolder: $(ArtifactsTestResultsFolder)"/>
		<Message Text="GitHub Action: $(GITHUB_ACTION)" />
		<Message Text="==> DONE"/>
	</Target>

	<!-- Check for API_GITHUB_KEY environment variable and print its length -->
	<Target Name="CHECK_GITHUB_KEY">
		<!-- If not set, print a clear message -->
		<Message Text="API_GITHUB_KEY is not set." Condition="'$(API_GITHUB_KEY)' == ''" Importance="high" />
		<!-- If set, compute length and print it -->
		<PropertyGroup Condition="'$(API_GITHUB_KEY)' != ''">
			<!-- Use System.String::Copy to get a string instance then read Length -->
			<GitHubKeyLength>$([System.String]::Copy($(API_GITHUB_KEY)).Length)</GitHubKeyLength>
		</PropertyGroup>
		<Message Text="API_GITHUB_KEY length: $(GitHubKeyLength)" Condition="'$(API_GITHUB_KEY)' != ''" Importance="high" />
		<Message Text="==> CHECK_GITHUB_KEY done" Importance="high" />
	</Target>

	<!-- Update ntools locally for testing -->
	<Target Name="UPDATE_NTOOLS" DependsOnTargets="IS_ADMIN" >
		<PropertyGroup>
			<SRC>$(SolutionDir)\nbuild\resources</SRC>
			<DST>$(DeploymentFolder)</DST>
		</PropertyGroup>
		<ItemGroup>
			<SourceFiles Include="
						 $(SRC)\ntools.json;
						 $(SRC)\*.targets" />
		</ItemGroup>
		<Copy SourceFiles="@(SourceFiles)" DestinationFolder="$(DST)" />
	</Target>

	<!-- Update the ntools-launcher nuget package in the local feed for testing - not needed for normal builds -->
	<Target Name="NUGET_UPDATE">
		<!--Nuget does not support updating a package in the local feed without version - so we need to remove it first-->
		<Exec Command='dotnet remove package ntools-launcher"' WorkingDirectory='$(SolutionDir)\Nbackup'></Exec>
		<Exec Command='dotnet remove package ntools-launcher"' WorkingDirectory='$(SolutionDir)\NbuildTasks'></Exec>
		<Exec Command='dotnet add package ntools-launcher  --source "C:\Artifacts\nupkgs"' WorkingDirectory='$(SolutionDir)\Nbackup'></Exec>
		<Exec Command='dotnet add package ntools-launcher  --source "C:\Artifacts\nupkgs"' WorkingDirectory='$(SolutionDir)\NbuildTasks'></Exec>
	</Target>

	<!-- Example of a target that displays a yellow color message -->
	<Target Name="YELLOW_MESSAGE">
		<ColorMessage Message="This is a message displayed in Yellow" Color="Yellow" />
	</Target>

	<!-- Example of a target that displays a red color message -->
	<Target Name="RED_MESSAGE">
		<ColorMessage Message="This is a message displayed in Red" Color="Red" />
	</Target>

	<!-- Install dotnet-outdated-tool globally -->
	<Target Name="INSTALL_DOTNET_OUTDATED_TOOL">
		<!-- Check if dotnet-outdated is already installed -->
		<Exec Command="dotnet tool list -g" ConsoleToMSBuild="true" ContinueOnError="true">
			<Output TaskParameter="ConsoleOutput" PropertyName="InstalledTools" />
		</Exec>
		
		<!-- Check if dotnet-outdated is in the list of installed tools -->
		<PropertyGroup>
			<IsOutdatedToolInstalled Condition="$(InstalledTools.Contains('dotnet-outdated-tool'))">true</IsOutdatedToolInstalled>
			<IsOutdatedToolInstalled Condition="'$(IsOutdatedToolInstalled)' == ''">false</IsOutdatedToolInstalled>
		</PropertyGroup>
		
		<Message Text="dotnet-outdated-tool is already installed globally." Condition="'$(IsOutdatedToolInstalled)' == 'true'" />
		
		<!-- Install only if not already installed -->
		<Exec Command="dotnet tool install --global dotnet-outdated-tool" Condition="'$(IsOutdatedToolInstalled)' == 'false'" />
		<Message Text="dotnet-outdated-tool installed globally." Condition="'$(IsOutdatedToolInstalled)' == 'false'" />
		
		<Message Text="==> DONE"/>
	</Target>

	<!-- Update all NuGet packages to the latest version -->
	<Target Name="UPDATE_NUGET_PACKAGES">
		<Exec Command="dotnet outdated --upgrade" WorkingDirectory="$(SolutionDir)" />
		<Message Text="NuGet packages updated to the latest version." />
		<Message Text="==> DONE"/>
	</Target>

	<!-- List all NuGet sources -->
	<Target Name="LIST_NUGET_SOURCES">
		<Exec Command="dotnet nuget list source" />
		<Message Text="Listed all NuGet sources." />
		<Message Text="==> DONE"/>
	</Target>

	<!-- Update documentation versions from JSON configuration files -->
	<UsingTask TaskName="NbuildTasks.UpdateVersionsInDocs" AssemblyFile="C:\source\ntools\Release\NbuildTasks.dll" />
	<UsingTask TaskName="NbuildTasks.GenerateCommitMessage" AssemblyFile="C:\source\ntools\Release\NbuildTasks.dll" />
	
	<Target Name="UPDATE_DOC_VERSIONS" DependsOnTargets="PROPERTIES">
		<UpdateVersionsInDocs 
			DevSetupPath="$(SolutionDir)\dev-setup" 
			DocsPath="$(SolutionDir)\docs\ntools\ntools.md" />
		<Message Text="Documentation versions updated successfully." />
		<Message Text="==> DONE"/>
	</Target>

	<!-- Intelligent commit message generation -->
	<Target Name="GENERATE_COMMIT_MESSAGE" DependsOnTargets="PROPERTIES">
		<PropertyGroup>
			<CommitType Condition="'$(CommitType)' == ''">feat</CommitType>
			<CommitScope Condition="'$(CommitScope)' == ''"></CommitScope>
			<CommitMessageFile Condition="'$(CommitMessageFile)' == ''">$(SolutionDir)\.commit-message</CommitMessageFile>
		</PropertyGroup>
		
		<GenerateCommitMessage 
			WorkingDirectory="$(SolutionDir)"
			CommitType="$(CommitType)"
			Scope="$(CommitScope)"
			CommitMessageFile="$(CommitMessageFile)">
			<Output TaskParameter="CommitMessage" PropertyName="GeneratedCommitMessage" />
		</GenerateCommitMessage>
		
		<Message Text="Generated commit message: $(GeneratedCommitMessage)" />
		<Message Text="==> DONE"/>
	</Target>

	<!-- Automated Git commit with intelligent message generation -->
	<Target Name="GIT_COMMIT_INFRASTRUCTURE" DependsOnTargets="UPDATE_DOC_VERSIONS;GENERATE_COMMIT_MESSAGE">
		<PropertyGroup>
			<!-- Use generated message if no custom message provided -->
			<FinalCommitMessage Condition="'$(CommitMessage)' == ''">$(GeneratedCommitMessage)</FinalCommitMessage>
			<FinalCommitMessage Condition="'$(CommitMessage)' != ''">$(CommitMessage)</FinalCommitMessage>
			<GitAddFiles Condition="'$(GitAddFiles)' == ''">.</GitAddFiles>
		</PropertyGroup>
		
		<!-- Check if there are any changes to commit -->
		<Exec Command="git status --porcelain" ConsoleToMSBuild="true" WorkingDirectory="$(SolutionDir)">
			<Output TaskParameter="ConsoleOutput" PropertyName="GitStatus" />
		</Exec>
		
		<Message Text="Git status: $(GitStatus)" Condition="'$(GitStatus)' != ''" />
		<Message Text="No changes to commit." Condition="'$(GitStatus)' == ''" />
		
		<!-- Add files to staging area -->
		<Exec Command="git add $(GitAddFiles)" 
			  WorkingDirectory="$(SolutionDir)" 
			  Condition="'$(GitStatus)' != ''" />
		<Message Text="Added files to staging area: $(GitAddFiles)" Condition="'$(GitStatus)' != ''" />
		
		<!-- Commit the changes with intelligent message -->
		<Exec Command='git commit -m "$(FinalCommitMessage)"' 
			  WorkingDirectory="$(SolutionDir)" 
			  Condition="'$(GitStatus)' != ''" />
		<Message Text="Committed changes with message: $(FinalCommitMessage)" Condition="'$(GitStatus)' != ''" />
		
		<Message Text="==> DONE"/>
	</Target>

	<!-- Combined target: Update versions and commit with smart message -->
	<Target Name="UPDATE_AND_COMMIT" DependsOnTargets="UPDATE_DOC_VERSIONS">
		<PropertyGroup>
			<CommitType>docs</CommitType>
			<CommitScope>automation</CommitScope>
		</PropertyGroup>
		
		<CallTarget Targets="GIT_COMMIT_INFRASTRUCTURE" />
		<Message Text="==> DONE"/>
	</Target>

	<!-- Full infrastructure update and commit with intelligent analysis -->
	<Target Name="INFRASTRUCTURE_COMMIT" DependsOnTargets="SOLUTION">
		<PropertyGroup>
			<CommitType Condition="'$(CommitType)' == ''">feat</CommitType>
			<CommitScope Condition="'$(CommitScope)' == ''">infrastructure</CommitScope>
		</PropertyGroup>
		
		<CallTarget Targets="GIT_COMMIT_INFRASTRUCTURE" />
		<Message Text="==> DONE"/>
	</Target>

	<!-- Preview commit message without committing -->
	<Target Name="PREVIEW_COMMIT_MESSAGE">
		<CallTarget Targets="GENERATE_COMMIT_MESSAGE" />
		<Message Text="==> Commit message preview complete. Check $(SolutionDir)\.commit-message file"/>
	</Target>

	<!-- Install ReportGenerator tool globally -->
	<Target Name="INSTALL_REPORTGENERATOR">
		<!-- Check if ReportGenerator is already installed -->
		<Exec Command="dotnet tool list -g" ConsoleToMSBuild="true" ContinueOnError="true">
			<Output TaskParameter="ConsoleOutput" PropertyName="InstalledTools" />
		</Exec>
		
		<!-- Check if reportgenerator is in the list of installed tools -->
		<PropertyGroup>
			<IsReportGeneratorInstalled Condition="$(InstalledTools.Contains('dotnet-reportgenerator-globaltool'))">true</IsReportGeneratorInstalled>
			<IsReportGeneratorInstalled Condition="'$(IsReportGeneratorInstalled)' == ''">false</IsReportGeneratorInstalled>
		</PropertyGroup>
		
		<Message Text="ReportGenerator is already installed globally." Condition="'$(IsReportGeneratorInstalled)' == 'true'" />
		
		<!-- Install only if not already installed -->
		<Exec Command="dotnet tool install -g dotnet-reportgenerator-globaltool" Condition="'$(IsReportGeneratorInstalled)' == 'false'" />
		<Message Text="ReportGenerator tool installed globally." Condition="'$(IsReportGeneratorInstalled)' == 'false'" />
		
		<Message Text="==> DONE"/>
	</Target>
	
	<!-- Creates a stage or prod release 
	Add for testing and remove after success-->
	<Target Name="GITHUB_RELEASE" DependsOnTargets="ARTIFACTS;GIT_BRANCH" AfterTargets="PROD"  >
		<Git Command="PushTag" TaskParameter="$(ProductVersion)" />
		<Exec Command='$(SolutionDir)\nbuild\bin\Release\nb.exe release_create --repo $(OWNER)/$(SolutionName) --tag $(ProductVersion) --branch $(GitBranch) --file $(ArtifactsFolder).zip' WorkingDirectory="$(SolutionDir)" />

		<Message Text="==> DONE"/>
	</Target>

	<!-- Creates a stage or prod pre-release 
	Add for testing and remove after success -->
	<Target Name="GITHUB_PRE_RELEASE" DependsOnTargets="ARTIFACTS;GIT_BRANCH" AfterTargets="STAGE" >
		<Git Command="PushTag" TaskParameter="$(ProductVersion)" />
		<Exec Command='"$(SolutionDir)\nbuild\bin\Release\nb.exe" pre_release_create --repo $(OWNER)/$(SolutionName) --tag $(ProductVersion) --branch $(GitBranch) --file $(ArtifactsFolder).zip --verbose' WorkingDirectory="$(SolutionDir)" />

		<Message Text="==> DONE"/>
	</Target>

	<!-- Run the focused ReleaseServiceFactoryTests via dotnet test -->
	<Target Name="RUN_RELEASESERVICEFACTORYTESTS">
		<Message Text="Running ReleaseServiceFactoryTests (focused)" Importance="high" />
		<Exec Command="dotnet test &quot;C:\source\ntools\ntools.sln&quot; --filter &quot;FullyQualifiedName~NbuildTests.ReleaseServiceFactoryTests&quot; -v minimal" WorkingDirectory="$(SolutionDir)" />
		<Message Text="==> RUN_RELEASESERVICEFACTORYTESTS DONE" />
	</Target>

	<!-- Pre-check: ensure no machine-level Debug/Release folders are present before running tests -->
	<Target Name="NB_PRECHECK">
		<Message Text="Running NB_PRECHECK: ensure C:\\Debug and C:\\Release do not exist on this machine" Importance="high" />
		<Error Condition="Exists('C:\\Debug')" Text="NB_PRECHECK failed: Found C:\\Debug. Please run 'nb CLEAN' locally to remove repository artifacts and retry, or remove C:\\Debug manually if you understand the contents." />
		<Error Condition="Exists('C:\\Release')" Text="NB_PRECHECK failed: Found C:\\Release. Please run 'nb CLEAN' locally to remove repository artifacts and retry, or remove C:\\Release manually if you understand the contents." />
		<Message Text="NB_PRECHECK passed: no machine-level Debug/Release folders found." Importance="high" />
	</Target>

	<!-- Run the full solution test suite (used by 'nb test') -->
	<Target Name="NB_TEST" DependsOnTargets="CLEAN;NB_PRECHECK">
		<Message Text='Running full solution tests sequentially via dev-setup\run-tests-sequential.ps1' Importance="high" />
		<!-- Use the existing script which stops lingering testhost/dotnet processes, removes local TestPlatform DLLs in Debug, and runs tests sequentially -->
		<Exec Command='powershell -NoProfile -ExecutionPolicy Bypass -File "$(SolutionDir)\dev-setup\run-tests-sequential.ps1"' WorkingDirectory="$(SolutionDir)" ConsoleToMSBuild="true">
			<Output TaskParameter="ExitCode" PropertyName="NbTestExitCode" />
			<Output TaskParameter="ConsoleOutput" PropertyName="NbTestOutput" />
		</Exec>
		<Message Text="$(NbTestOutput)" Condition="'$(NbTestOutput)' != ''" Importance="high" />
		<Message Text="==> NB_TEST DONE" />
		<Error Condition="'$(NbTestExitCode)' != '0'" Text="NB_TEST failed. See output above for details." />
	</Target>

	<!-- Diagnostic target to run automatically after NB_TEST to list TestFramework DLLs -->
	<Target Name="NB_TEST_DIAGNOSTICS" AfterTargets="NB_TEST">
		<Message Text="==> NB_TEST_DIAGNOSTICS: listing TestFramework DLLs in Debug" Importance="high" />
		<!-- Run extended diagnostics script which enumerates copies of test-platform/MSTest DLLs and lists package graphs for test projects -->
		<Exec Command='powershell -NoProfile -ExecutionPolicy Bypass -File "$(SolutionDir)\dev-setup\nb_test_diagnostics_more.ps1" "$(SolutionDir)"' WorkingDirectory="$(SolutionDir)" ConsoleToMSBuild="true">
			<Output TaskParameter="ConsoleOutput" PropertyName="NbTestDiagnosticsOutput" />
		</Exec>
		<Message Text="$(NbTestDiagnosticsOutput)" Importance="high" Condition="'$(NbTestDiagnosticsOutput)' != ''" />
		<Message Text="==> NB_TEST_DIAGNOSTICS DONE" Importance="high" />
	</Target>

	<!-- Per-test-project diagnostic targets: run dotnet test with 'diag' to capture VSTest assembly load data -->
	<!-- Targets auto-generated: one per Tests.csproj in the solution -->
	<Target Name="NB_DIAG_NbuildTasksTests">
		<Message Text="Running diag for NbuildTasksTests" Importance="high" />
		<Exec Command='dotnet test "$(SolutionDir)\NbuildTasksTests\NbuildTasksTests.csproj" --diag:"$(SolutionDir)\TestResults\NbuildTasksTests-diag-vstest.txt" -v minimal' WorkingDirectory="$(SolutionDir)" />
	</Target>

	<Target Name="NB_DIAG_NbuildTests">
		<Message Text="Running diag for NbuildTests" Importance="high" />
		<Exec Command='dotnet test "$(SolutionDir)\NbuildTests\NbuildTests.csproj" --diag:"$(SolutionDir)\TestResults\NbuildTests-diag-vstest.txt" -v minimal' WorkingDirectory="$(SolutionDir)" />
	</Target>

	<Target Name="NB_DIAG_lfTests">
		<Message Text="Running diag for lfTests" Importance="high" />
		<Exec Command='dotnet test "$(SolutionDir)\lfTests\lfTests.csproj" --diag:"$(SolutionDir)\TestResults\lfTests-diag-vstest.txt" -v minimal' WorkingDirectory="$(SolutionDir)" />
	</Target>

	<Target Name="NB_DIAG_nbTests">
		<Message Text="Running diag for nbTests" Importance="high" />
		<Exec Command='dotnet test "$(SolutionDir)\nbTests\nbTests.csproj" --diag:"$(SolutionDir)\TestResults\nbTests-diag-vstest.txt" -v minimal' WorkingDirectory="$(SolutionDir)" />
	</Target>

	<Target Name="NB_DIAG_nBackupTests">
		<Message Text="Running diag for nBackupTests" Importance="high" />
		<Exec Command='dotnet test "$(SolutionDir)\nBackupTests\NbackupTests.csproj" --diag:"$(SolutionDir)\TestResults\nBackupTests-diag-vstest.txt" -v minimal' WorkingDirectory="$(SolutionDir)" />
	</Target>

	<Target Name="NB_DIAG_wiTests">
		<Message Text="Running diag for wiTests" Importance="high" />
		<Exec Command='dotnet test "$(SolutionDir)\wiTests\wiTests.csproj" --diag:"$(SolutionDir)\TestResults\wiTests-diag-vstest.txt" -v minimal' WorkingDirectory="$(SolutionDir)" />
	</Target>

	<Target Name="NB_DIAG_GitHubReleaseTests">
		<Message Text="Running diag for GitHubReleaseTests" Importance="high" />
		<Exec Command='dotnet test "$(SolutionDir)\GitHubReleaseTests\GitHubReleaseTests.csproj" --diag:"$(SolutionDir)\TestResults\GitHubReleaseTests-diag-vstest.txt" -v minimal' WorkingDirectory="$(SolutionDir)" />
	</Target>

	<!-- Aggregate target: run all per-project diagnostics sequentially -->
	<Target Name="NB_TEST_DIAG_ALL" DependsOnTargets="NB_DIAG_NbuildTasksTests;NB_DIAG_NbuildTests;NB_DIAG_lfTests;NB_DIAG_nbTests;NB_DIAG_nBackupTests;NB_DIAG_wiTests;NB_DIAG_GitHubReleaseTests">
		<Message Text=">== NB_TEST_DIAG_ALL completed" Importance="high" />
	</Target>

	<!-- Clean up the project and artifacts folder -->
	<Target Name="CLEAN">
		<Message Text="Cleaning repository: removing bin/, obj/, Debug/, Release/, TestResults/, CoverageReport/ and artifacts (safe mode)" Importance="high" />

		<!-- Safety: ensure SolutionDir is set to avoid accidental root-level deletes -->
		<PropertyGroup>
			<_SolutionDir>$(SolutionDir)</_SolutionDir>
		</PropertyGroup>

		<Error Condition="'$(_SolutionDir)' == ''" Text="CLEAN aborted: $(SolutionDir) is not set. This prevents unsafe deletes." />

		<!-- Collect directories to remove (MSBuild supports wildcards in Item Include) -->
		<ItemGroup>
			<DirectoriesToRemove Include="$(_SolutionDir)**\bin;
										$(_SolutionDir)**\obj;
										$(_SolutionDir)Debug;
										$(_SolutionDir)Release;
										$(_SolutionDir)TestResults;
										$(_SolutionDir)CoverageReport;
										c:\debug;
										c:\release;
										$(_SolutionDir)artifacts" />
		</ItemGroup>

		<Message Text="Directories to remove: @(DirectoriesToRemove)" Importance="high" />
		<RemoveDir Directories="@(DirectoriesToRemove)" />

		<Message Text="Cleaning complete." Importance="high" />
	</Target>

	<!-- Create a stage package for testing -->
	<Target Name="STAGE" DependsOnTargets="STAGE_NEW" >
		<Message Text="STAGE target completed - delegated to STAGE_NEW in common.targets" />
		<Message Text="==> DONE"/>
  	</Target>

	<!-- Create a PROD package for release (delegates to PROD_NEW in common.targets) -->
	<Target Name="PROD" DependsOnTargets="PROD_NEW" >
		<Message Text="PROD target completed - delegated to PROD_NEW in common.targets" />
		<Message Text="==> DONE"/>
	</Target>

    <!-- Comprehensive smoke test to verify published artifacts and build system integrity -->
    <Target Name="SMOKE_TEST" DependsOnTargets="ARTIFACTS">
        <Message Text="Running comprehensive smoke test for artifacts and build system..." />
        
        <!-- 1. ARTIFACTS VALIDATION -->
        <Message Text="=== 1. Artifacts Validation ===" />
        
        <!-- Check if artifacts folder exists -->
        <Error Condition="!Exists('$(ArtifactsFolder)')" 
               Text="Artifacts folder not found at: $(ArtifactsFolder). Please run 'nb PUBLISH' first to generate artifacts." />
        
        <!-- Define executables to test using ItemGroup -->
        <ItemGroup>
            <ExecutablesToTest Include="$(ArtifactsFolder)\nb.exe">
                <DisplayName>nb.exe (Core executable)</DisplayName>
                <TestCommand>--version</TestCommand>
                <HelpCommand>install --help</HelpCommand>
                <Required>true</Required>
            </ExecutablesToTest>
            <ExecutablesToTest Include="$(ArtifactsFolder)\lf.exe">
                <DisplayName>lf.exe (List files utility)</DisplayName>
                <TestCommand>--help</TestCommand>
                <HelpCommand></HelpCommand>
                <Required>true</Required>
            </ExecutablesToTest>
            <ExecutablesToTest Include="$(ArtifactsFolder)\nBackup.exe">
                <DisplayName>nBackup.exe (Backup utility)</DisplayName>
                <TestCommand>--help</TestCommand>
                <HelpCommand></HelpCommand>
                <Required>true</Required>
            </ExecutablesToTest>
            <ExecutablesToTest Include="$(ArtifactsFolder)\wi.exe">
                <DisplayName>wi.exe (Work items utility)</DisplayName>
                <TestCommand>--help</TestCommand>
                <HelpCommand></HelpCommand>
                <Required>true</Required>
            </ExecutablesToTest>
            <!-- Optional executables - only test if they exist -->
            <ExecutablesToTest Include="$(ArtifactsFolder)\GitHubRelease.exe">
                <DisplayName>GitHubRelease.exe (GitHub release utility)</DisplayName>
                <TestCommand>--help</TestCommand>
                <HelpCommand></HelpCommand>
                <Required>false</Required>
            </ExecutablesToTest>
        </ItemGroup>
        
        <!-- Verify required executables exist -->
        <Message Text="Checking required executable files..." />
        <Error Condition="'%(ExecutablesToTest.Required)' == 'true' And !Exists('%(ExecutablesToTest.Identity)')" 
               Text="❌ Required executable not found: %(ExecutablesToTest.DisplayName) at %(ExecutablesToTest.Identity)" />
        
        <!-- Filter to only existing executables for testing -->
        <ItemGroup>
            <ExistingExecutables Include="@(ExecutablesToTest)" Condition="Exists('%(ExecutablesToTest.Identity)')" />
        </ItemGroup>
        
        <!-- Count executables -->
        <PropertyGroup>
            <ExecutableCount>@(ExistingExecutables->Count())</ExecutableCount>
        </PropertyGroup>
        
        <Message Text="✅ Found $(ExecutableCount) executables to test" />
        
        <!-- Test each executable using MSBuild batching -->
        <Message Text="Testing executables..." />
        <Exec Command='"%(ExistingExecutables.Identity)" %(ExistingExecutables.TestCommand)' 
              ContinueOnError="true" 
              IgnoreExitCode="true">
            <Output TaskParameter="ExitCode" PropertyName="ExitCode_%(ExistingExecutables.Filename)" />
        </Exec>
        
        <!-- Test additional commands for nb.exe -->
        <Message Text="Testing additional nb.exe commands..." />
        <Exec Command='"$(ArtifactsFolder)\nb.exe" install --help' 
              ContinueOnError="true" 
              IgnoreExitCode="true"
              Condition="Exists('$(ArtifactsFolder)\nb.exe')">
            <Output TaskParameter="ExitCode" PropertyName="NbInstallHelpExitCode" />
        </Exec>
        
        <!-- Report results for each executable -->
        <Message Text="=== Test Results ===" />
        <Message Text="✅ %(ExistingExecutables.DisplayName): Exit code $(ExitCode_%(ExistingExecutables.Filename))" 
                 Condition="'$(ExitCode_%(ExistingExecutables.Filename))' == '0'" />
        <Message Text="✅ %(ExistingExecutables.DisplayName): Exit code $(ExitCode_%(ExistingExecutables.Filename)) (acceptable for help command)" 
                 Condition="'%(ExistingExecutables.Filename)' == 'nBackup' And '$(ExitCode_%(ExistingExecutables.Filename))' == '-1'" />
        <Message Text="❌ %(ExistingExecutables.DisplayName): Exit code $(ExitCode_%(ExistingExecutables.Filename))" 
                 Condition="'$(ExitCode_%(ExistingExecutables.Filename))' != '0' And '%(ExistingExecutables.Filename)' != 'nBackup'" />
        <Message Text="❌ %(ExistingExecutables.DisplayName): Exit code $(ExitCode_%(ExistingExecutables.Filename))" 
                 Condition="'%(ExistingExecutables.Filename)' == 'nBackup' And '$(ExitCode_%(ExistingExecutables.Filename))' != '0' And '$(ExitCode_%(ExistingExecutables.Filename))' != '-1'" />
        
        <Message Text="✅ nb install --help: Exit code $(NbInstallHelpExitCode)" Condition="'$(NbInstallHelpExitCode)' == '0'" />
        <Message Text="❌ nb install --help: Exit code $(NbInstallHelpExitCode)" Condition="'$(NbInstallHelpExitCode)' != '0'" />
        
        <!-- 2. BUILD SYSTEM VALIDATION -->
        <Message Text="=== 2. Build System Validation ===" />
        
        <!-- Target delegation validation -->
        <PropertyGroup>
            <SourceTarget Condition="'$(SourceTarget)' == ''">STAGE</SourceTarget>
            <DelegateTarget Condition="'$(DelegateTarget)' == ''">STAGE_NEW</DelegateTarget>
            <SourceFile Condition="'$(SourceFile)' == ''">$(SolutionDir)\nbuild.targets</SourceFile>
            <DelegateFile Condition="'$(DelegateFile)' == ''">$(SolutionDir)\Nbuild\resources\common.targets</DelegateFile>
        </PropertyGroup>
        
        <Message Text="Testing MSBuild target delegation: $(SourceTarget) -> $(DelegateTarget)" />
        
        <!-- Verify target files exist -->
        <Error Condition="!Exists('$(SourceFile)')" Text="❌ Source file not found: $(SourceFile)" />
        <Error Condition="!Exists('$(DelegateFile)')" Text="❌ Delegate file not found: $(DelegateFile)" />
        <Message Text="✅ Both target files exist" />
        
        <!-- Use consolidated PowerShell module for target validation -->
	<Exec Command='pwsh -NoProfile -ExecutionPolicy Bypass -Command "Import-Module &apos;$(BuildTools)\ntools-scripts.psm1&apos; -Force; Test-TargetDelegation -SourceTarget &apos;$(SourceTarget)&apos; -DelegateTarget &apos;$(DelegateTarget)&apos;"' 
              WorkingDirectory="$(SolutionDir)" 
              ContinueOnError="true" 
              IgnoreExitCode="true">
            <Output TaskParameter="ExitCode" PropertyName="DelegationTestExitCode" />
        </Exec>
        
        <Message Text="✅ Target delegation test passed" Condition="'$(DelegationTestExitCode)' == '0'" />
        <Message Text="❌ Target delegation test failed: Exit code $(DelegationTestExitCode)" Condition="'$(DelegationTestExitCode)' != '0'" />
        
        <!-- 3. SUMMARY -->
        <Message Text="=== Smoke Test Summary ===" />
        
        <!-- Calculate overall success (all exit codes should be 0, except nBackup which returns -1 for help) -->
        <PropertyGroup>
            <!-- nBackup.exe returns -1 for help command, which is acceptable -->
            <NBackupSuccess Condition="'$(ExitCode_nBackup)' == '0' Or '$(ExitCode_nBackup)' == '-1'">true</NBackupSuccess>
            <NBackupSuccess Condition="'$(NBackupSuccess)' == ''">false</NBackupSuccess>
            
            <AllTestsPassed Condition="'$(ExitCode_nb)' == '0' And '$(ExitCode_lf)' == '0' And '$(NBackupSuccess)' == 'true' And '$(ExitCode_wi)' == '0' And '$(NbInstallHelpExitCode)' == '0' And '$(DelegationTestExitCode)' == '0'">true</AllTestsPassed>
            <AllTestsPassed Condition="'$(AllTestsPassed)' == ''">false</AllTestsPassed>
        </PropertyGroup>
        
        <Message Text="✅ Comprehensive smoke test completed successfully - All $(ExecutableCount) executables validated" Condition="'$(AllTestsPassed)' == 'true'" />
        <Error Condition="'$(AllTestsPassed)' == 'false'" 
               Text="❌ Smoke test failed. Check individual test results above." />
        
        <Message Text="==> DONE" />
    </Target>

	<!-- Artifact verification: runs consolidated module function Invoke-VerifyArtifacts -->
	<Target Name="VERIFY_ARTIFACTS" DependsOnTargets="ARTIFACTS">
		<Message Text="Running artifact verification via ntools-scripts module" Importance="high" />
		<Exec Command='pwsh -NoProfile -NonInteractive -ExecutionPolicy Bypass -Command "Import-Module &apos;.\scripts\module-package\ntools-scripts.psm1&apos; -Force; $r = Invoke-VerifyArtifacts -ArtifactsPath &apos;$(ArtifactsFolder)&apos; -ProductVersion &apos;$(ProductVersion)&apos;; if ($r.Error -gt 0) { exit 1 } else { exit 0 }"' WorkingDirectory="$(SolutionDir)" />
		<Message Text="VERIFY_ARTIFACTS completed" Importance="high" />
	</Target>
		
	<!-- Build SDO package for inclusion in NTools distribution -->
	<Target Name="BUILD_SDO" DependsOnTargets="ARTIFACTS">
		<Message Text="Building SDO package..." Importance="high" />
		<PropertyGroup>
			<SdoSourceDir>$(SolutionDir)\atools</SdoSourceDir>
		</PropertyGroup>

		<!-- Copy SDO installation script and documentation -->
		<Message Text="Copying SDO installation files..." Importance="high" />
		<Copy SourceFiles="$(SdoSourceDir)\install-sdo.py" DestinationFiles="$(ArtifactsFolder)\install-sdo.py" />
		<Copy SourceFiles="$(SolutionDir)\docs\atools\sdo-installation.md" DestinationFiles="$(ArtifactsFolder)\SDO_INSTALL_README.md" />
		<Copy SourceFiles="$(SdoSourceDir)\pyproject.toml" DestinationFiles="$(ArtifactsFolder)\pyproject.toml" />

		<!-- Copy SDO package directory to artifacts folder -->
		<ItemGroup>
			<SdoPackageFiles Include="$(SolutionDir)\atools\sdo_package\**\*.*" />
		</ItemGroup>
		<Copy SourceFiles="@(SdoPackageFiles)" DestinationFiles="@(SdoPackageFiles->'$(ArtifactsFolder)\sdo_package\%(RecursiveDir)%(Filename)%(Extension)')" />

		<Message Text="SDO package built successfully with virtual environment installer" Importance="high" />
		<Message Text="==> BUILD_SDO DONE"/>
	</Target>

	<!-- Publish all non-test projects to artifacts folder -->
	<Target Name="PUBLISH" DependsOnTargets="ARTIFACTS;TAG">
		<RemoveDir Directories="$(ArtifactsFolder)"></RemoveDir>
		<Message Text="Publishing all non-test projects using ntools-scripts module" Importance="high" />
		<Exec Command='pwsh -NoProfile -ExecutionPolicy Bypass -Command "Import-Module &apos;$(BuildTools)\ntools-scripts.psm1&apos; -Force; Publish-AllProjects -OutputDir &apos;$(ArtifactsFolder)&apos; -Version &apos;$(ProductVersion)&apos; -RepositoryRoot &apos;$(SolutionDir)&apos;"' WorkingDirectory="$(SolutionDir)" />
		<Message Text="All non-test projects published to $(ArtifactsFolder)" Importance="high" />
		
		<CallTarget Targets="BUILD_SDO" />
		
		<Message Text="==> PUBLISH DONE"/>
	</Target>
</Project>
